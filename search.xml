<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Leetcode 题解 in Python (4)]]></title>
      <url>%2F2017%2F02%2F15%2FLeetcode-Python-Solution-Part4%2F</url>
      <content type="text"><![CDATA[接上篇。 过完年，终于可以继续愉快地更新了。越到后面的题，越发感觉到了对于算法效率的要求，好几道题都出现了 Time Limit Exceeded，导致没能通过测试。有的用到了之前用过的双指针，有的用到了 ASCII 码，或者 XOR 操作，这些都是没见过的，可以为以后的解题提供一些思路。 Pascal’s Triangle (#118)Given numRows, generate the first numRows of Pascal’s triangle.For example, given numRows = 5,Return1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 首先将第一行特殊处理，只有一个元素1；从第二行开始，先设定默认值 [1,1]，作为首尾的值，然后在中间不停插入上一行对应元素相加的和为新的元素，直到这一行 list 的长度与行号相同：33.26% 123456789101112131415161718def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ returnList = [] for i in range(numRows): if i == 0: returnList.append([1]) continue l = [1, 1] lastl = returnList[-1] flag = 1 while len(l) &lt;= i: l.insert(flag, lastl[flag-1] + lastl[flag]) flag += 1 returnList.append(l) return returnList 任何一行的数值可以通过前一行和前一行的偏移来构建出来，如下所示：60.57% 123 1 3 3 1 0 + 0 1 3 3 1= 1 4 6 4 1 12345678910111213def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ res = [[1]] for i in range(1, numRows): # Python 2 res += [map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1])] return res[:numRows]# Python 3 res.append(list(map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1]))) Pascal’s Triangle II (#119)Given an index k, return the kth row of the Pascal’s triangle.For example, given k = 3,Return [1,3,3,1]. NOTECould you optimize your algorithm to use only O(k) extra space? 与 #118 题类似：22.83% 12345678910def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ last= new = [1] for i in range(rowIndex): new = list(map(lambda x,y:x+y, last + [0], [0] + last)) last = new return new 相比于上面使用 map，速度快30%：75.30% 123456789def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ row = [1] for _ in range(rowIndex): row = [x + y for x, y in zip([0]+row, row+[0])] return row Best Time to Buy and Sell Stock (#121)Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 循环列表中的每一个数，计算它与前面所有数的差值：无法通过测试，在处理大量数据的时候很慢 123456789101112def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ maxp = 0 for i in range(1, len(prices)): for j in range(0, i): profit = prices[i] - prices[j] if profit &gt; maxp: maxp = profit return maxp 通过两个变量 maxSoFar 来记录当前的最大值，maxCur 来记录当新的一个数读进来之后，当前的最大值：27.37% MARK：巧妙解题思路12345678910def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ maxCur = maxSoFar = 0 for i in range(1, len(prices)): maxCur = max(0, maxCur + prices[i] - prices[i-1]) maxSoFar = max(maxCur, maxSoFar) return maxSoFar 画出变化折线图可以看出，主要是寻找波峰和波谷：55.96% 12345678910111213def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ maxprofit = 0 minPrice = float('inf') for i in range(len(prices)): if prices[i] &lt; minPrice: minPrice = prices[i] elif prices[i] - minPrice &gt; maxprofit: maxprofit = prices[i] - minPrice return maxprofit Best Time to Buy and Sell Stock II (#122)Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 后一天的值比前一天大，就将差值加入到总的利润中去（相当于卖出）；后一填比前一天小就更新最小值（相当于买入）：74.33% 123456789101112def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ total_profit = 0 minPrice = float('inf') for i in range(len(prices)): if prices[i] &gt; minPrice: total_profit += prices[i] - minPrice minPrice = prices[i] return total_profit 上面的算法等于下面的算法：33.30% 123456def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1)) Valid Palindrome (#125)Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome. NOTEHave you consider that the string might be empty? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. 先用一个 list 来存储字符串中的所有字母和数字，然后验证该 list 中的所有字符是否是回文字符：19.07% 123456789101112131415def isPalindrome(self, s): """ :type s: str :rtype: bool """ l = [] for c in s: if (c &gt;= 'a' and c &lt;= 'z') or (c &gt;= '0' and c &lt;= '9'): l.append(c) elif c &gt;= 'A' and c &lt;= 'Z': l.append(c.lower()) for i in range((len(l)+1)//2): if not l[i] == l[len(l)-1-i]: return False return True 两个标记 l、r，分别指向需要验证的两个字符，l 从前往后找为下一个是数字或字母的字符， r 从后往前找下一个是数字或字母的字符：16.60% MARK：isalnum() 方法检测是否由字母和数字组成123456789101112131415def isPalindrome(self, s): """ :type s: str :rtype: bool """ l, r = 0, len(s)-1 while l &lt; r: while l &lt; r and not s[l].isalnum(): l += 1 while l &lt;r and not s[r].isalnum(): r -= 1 if s[l].lower() != s[r].lower(): return False l +=1; r -= 1 return True Single Number (#136)Given an array of integers, every element appears twice except for one. Find that single one. NOTEYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 不停 pop 出 list 中最后一个元素，然后在剩下的 list 中找到与这个元素相等的元素，然后从 list 中移除，如果找不到则返回这个数值：无法通过测试，效率太低 12345678910def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ while nums: c = nums.pop() if not c in nums: return c nums.remove(c) 利用字典来存储每个字符出现的次数，遍历一次 list 即可统计出来，然后返回 key 对应 value 为 1 的那个 key：14.15% 1234567891011121314def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ d = &#123;&#125; for c in nums: if not c in d: d[c] = 1 else: d[c] += 1 for i in d.keys(): if d[i] == 1: return i 利用 XOR 操作提高算法效率：67.34% 12345670 ^ N = NN ^ N = 0N1 ^ N1 ^ N2 ^ N2 ^ …… ^ Nx ^ Nx ^ N= (N1^N1) ^ (N2^N2) ^ …… ^ (Nx^Nx) ^ N= 0 ^ 0 ^ …… ^ 0 ^ N= N MARK：XOR 操作123456789def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ result = 0 for i in range(len(nums)): result ^= nums[i] return result Linked List Cycle (#141)Given a linked list, determine if it has a cycle in it.Follow up:Can you solve it without using extra space? 将链表从头开始每个节点加入一个 list 中，然后寻找下一个节点，如果该节点已经存在于列表中，那么说明存在环：无法通过测试，效率太低 123456789101112131415def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False flag, l = head, [] l.append(flag) while flag.next: if flag.next in l: return True else: l.append(flag.next) flag = flag.next return False 利用两个指针 slow 和 fast，slow 每次循环往前走一个，fast 每次循环往前走两个，如果该节点列表中存在环，那么总有一步两个指针会相遇：95.85% 1234567891011121314def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False Min Stack (#155)Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 利用 list 进行存储与操作：无法通过测试，效率太低 12345678910111213141516171819202122232425262728293031323334class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.values = [] def push(self, x): """ :type x: int :rtype: void """ self.values.append(x) def pop(self): """ :rtype: void """ return self.values.pop() def top(self): """ :rtype: int """ return self.values[-1] def getMin(self): """ :rtype: int """ return min(self.values) 上面存在问题，当计算最小值时，利用 min 函数的效率太低，因此，当新 push 进一个数的时候，应该同时储存此时所有元素最小的元素值是多少（或者利用一个变量存储此时的）：42.46% 12345678910111213141516171819202122232425262728293031323334353637383940414243class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.values = [] def push(self, x): """ :type x: int :rtype: void """ curMin = self.getMin() if curMin == None or x &lt; curMin: curMin = x self.q.append((x, curMin)); def pop(self): """ :rtype: void """ return self.values.pop() def top(self): """ :rtype: int """ if len(self.q) == 0: return None else: return self.q[len(self.q) - 1][0] def getMin(self): """ :rtype: int """ if len(self.q) == 0: return None else: return self.q[len(self.q) - 1][1] Two Sum II - Input array is sorted (#167)Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.12Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 处理有很多值重复的情况，不然运行会超时，效率过低。分两种情况处理：1）如果应该分解成两个一样的值，那么判断后一个是否等于当前的值；2）如果不应该分解成两个一样的值，那么跳过所有相同的值，不再在这个值的时候遍历寻找另一个值：27.92% 1234567891011121314151617181920212223def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ last = numbers[-1] for i in range(len(numbers)): d1 = numbers[i] if d1 != target - d1: if d1 == last: last = d1 continue else: if numbers[i+1] == d1: return [i+1,i+2] for ii in range(i+1, len(numbers)): d2 = numbers[ii] if d2 == target - d1: return [i+1, ii+1] if d2 &gt; target - d1: break last = d1 利用双指针，当和大于目标值时，大指针向前挪动；当和小于目标值时，小指针向后挪动：70.18% MARK：双指针123456789101112131415def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ l, r = 0, len(numbers)-1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: return [l+1, r+1] elif s &lt; target: l += 1 else: r -= 1 Excel Sheet Column Title (#168)Given a positive integer, return its corresponding column title as appear in an Excel sheet.For example:12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB 通过递归求解，首先生成一个 list用来储存 1-26 数字对应的字母，然后不停除以 26 求整数商以及余数，于是问题变成求这个商对应的字母加上余数对应的字母：80.54% MARK：ASCII 码1234567891011121314151617def convertToTitle(self, n): """ :type n: int :rtype: str """ l = [] for asciiNum in range(65, 91): l.append(chr(asciiNum)) return self.getOne(n,l)def getOne(self, n, l): quotient = (n-1) // 26 remainder = n % 26 if quotient: return self.getOne(quotient, l) + l[remainder-1] else: return l[remainder-1] 上面的函数可以简写成下面的形式：15.24% MARK：ASCII 码123456def convertToTitle(self, n): """ :type n: int :rtype: str """ return "" if n == 0 else self.convertToTitle((n - 1) // 26) + chr((n - 1) % 26 + ord('A')) 未完，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2017/02/15/Leetcode-Python-Solution-Part4/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Leetcode 题解 in Python (3)]]></title>
      <url>%2F2017%2F01%2F21%2FLeetcode-Python-Solution-Part3%2F</url>
      <content type="text"><![CDATA[接上篇。过年前最后一次更新，鸡年见！ Remove Duplicates from Sorted List (#83)Given a sorted linked list, delete all duplicates such that each element appear only once.For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 又是一道链表的题，可以使用前面经常使用的双指针的方法，特殊处理一下链表为空的情况：36.42% 12345678910111213141516def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head fast = slow = head while fast.next: fast = fast.next if fast.val == slow.val: continue else: slow.next = fast slow = slow.next slow.next = fast.next return head 利用一个指针，其中用了一些技巧，例如，cur.next.val 不一定存在，于是可以用条件判断语句，先执行 cur.next，如果为 False，那么后面的也不会执行。内部的 while循环跳过了所有与当前值不相等的值，新的 cur.next 的值作为外面循环的新值传入：77.78% 1234567891011def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ cur = head while cur: while cur.next and cur.next.val == cur.val: cur.next = cur.next.next # skip duplicated node cur = cur.next # not duplicate of current node, move to next node return head Merge Sorted Array (#88)Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. NOTEYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 首先理解题意，nums1 实际的长度是 m+n，其中前 m 个是 nums1 本身自己的值，而后面 n 个填充为 0。可以从后往前依次比较 nums1 和 nums2 的数的大小，将较大的赋给相应的值，依次循环。注意处理其中一个已经全部赋完值的情况：50.82% 12345678910111213141516171819202122232425def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ index = m + n while index &gt;= 0: if n == 0: nums1[:index] = nums1[:m] break if m ==0: nums1[:index] = nums2[:n] break index -= 1 num1 = nums1[m-1] num2 = nums2[n-1] if num1 &gt; num2: nums1[index] = num1 m -= 1 else: nums1[index] = num2 n -= 1 基本思想与上面一致，但是利用 nums1 和 nums2 各自的 index 来进行循环，最后处理 nums2 中还有值的情况：72.12% 1234567891011121314151617def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] Same Tree (#100)Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 通过递归的方法来判断，如果一个点是叶子节点，那么它的 left 和 right 都是 None，此时比较两者是否同时为 None；如果不是叶子节点，那么比较该节点的 val，以及对 left 和 right 进行递归判断：48.38% 12345678910111213141516# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return p == q 值得注意：if not a or b 和 if not (a or b) 不一样，前者相当于 if (not a) or b。 上面可以写成如下的形式，但是可读性太差：48.38% 1234567def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q 将两个数分别按照其树结构，形成对应的tuple，最后比较两个tuple是否相等即可，但不容易想到：86.56% MARK：tupleify，元祖化123456789def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ def t(n): return n and (n.val, t(n.left), t(n.right)) return t(p) == t(q) Symmetric Tree (#101)Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).For example, this binary tree [1,2,2,3,4,4,3] is symmetric:12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not:12345 1 / \2 2 \ \ 3 3 NOTEBonus points if you could solve it both recursively and iteratively. MARK：× 利用递归，当传入的有一个为 None 时，判断左右是否相等；当左右都不为 None 时，首先如果两者的 val 不相等，那么肯定不同；然后，递归调用判断 left.left 和 right.right、left.right 和 right.left 是否相等：36.83% 12345678910111213def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ return root == None or self.isSymmetricIter(root.left, root.right) def isSymmetricIter(self, left, right): if not (left and right): return left == right if not left.val == right.val: return False return self.isSymmetricIter(left.left, right.right) and self.isSymmetricIter(left.right, right.left) 递归的本质是使用堆栈，因此使用循环和堆栈来实现：33.67% 123456789101112131415161718192021222324def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if root is None: return True stack = [[root.left, root.right]] while len(stack) &gt; 0: pair = stack.pop(0) left = pair[0] right = pair[1] if left is None and right is None: continue if left is None or right is None: return False if left.val == right.val: stack.insert(0, [left.left, right.right]) stack.insert(0, [left.right, right.left]) else: return False return True Binary Tree Level Order Traversal (#102)Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).For example:Given binary tree [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 return its level order traversal as:12345[ [3], [9,20], [15,7]] 利用一个新的 list 来记录要返回的值，另外一个 list 来记录下一次要去循环的所有节点： 64.71% 1234567891011121314151617181920212223242526272829303132def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if root is None: return [] result = [[root.val]] if root.right and root.left: stack = [root.right,root.left] elif root.right: stack = [root.right] elif root.left: stack = [root.left] else: return result while len(stack) &gt; 0: (appendl,temp) = self.valueInList(stack) if not len(appendl) == 0: result.append(appendl) stack = temp return result def valueInList(self, stack): temp = [] appendl = [] while len(stack)&gt;0: node = stack.pop() appendl.append(node.val) if node.left: temp.insert(0, node.left) if node.right: temp.insert(0, node.right) return (appendl,temp) BFS，广度优先搜索。利用 list 生成器，简化表达式，将下一层需要添加的非空节点放进 level 列表中，将这一层所有节点的 val 值组成 list 添加到最后返回的 ans 列表中：43.97% MARK：BFS、层序遍历1234567891011def levelOrder(root): """ :type root: TreeNode :rtype: List[List[int]] """ ans, level = [], [root] while root and level: ans.append([node.val for node in level]) LRpair = [(node.left, node.right) for node in level] level = [leaf for LR in LRpair for leaf in LR if leaf] return ans Maximum Depth of Binary Tree (#104)Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 根据上一题的第二种思路，将 val 变成 list 加入答案的步骤改为层数 +1： 97.04% 1234567891011def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ ans, level = 0, [root] while root and level: ans += 1 LRpair = [(node.left,node.right) for node in level] level = [leaf for LR in LRpair for leaf in LR if leaf] return ans 使用递归，但效率较差：12.26% 123456def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ return 1 + max(map(self.maxDepth, (root.left, root.right))) if root else 0 DFS，深度优先搜索。分别找到树每一条分支路径的深度，返回最大的深度作为二叉树的深度：51.02% MARK：DFS123456789101112131415161718192021def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if root is None: return 0 stack = [root] value = [1] result = 0 while len(stack)&gt;0: node = stack.pop(0) temp = value.pop(0) result = max(temp, result) if not node.right is None: stack.append(node.right) value.append(temp+1) if not node.left is None: stack.append(node.left) value.append(temp+1) return result Binary Tree Level Order Traversal II (#107)Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).For example:Given binary tree [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as:12345[ [15,7], [9,20], [3]] BFS。将 #102 题中顺序加入改成每次加入到最前面，即倒叙进行输出：7.86% 1234567891011def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ ans, level = [], [root] while root and level: ans.insert(0, [node.val for node in level]) LRpair = [(node.left, node.right) for node in level] level = [leaf for LR in LRpair for leaf in LR if leaf] return ans DFS + 堆栈。：41.37% 12345678910111213141516def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ stack = [(root, 0)] res = [] while stack: node, level = stack.pop() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) stack.append((node.right, level+1)) stack.append((node.left, level+1)) return res DFS + 递归。：63.79% 12345678910111213141516def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] self.dfs(root, 0, res) return resdef dfs(self, root, level, res): if root: if len(res) &lt; level + 1: res.insert(0, []) res[-(level+1)].append(root.val) self.dfs(root.left, level+1, res) self.dfs(root.right, level+1, res) Balanced Binary Tree (#110)Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 利用 #104 计算数深度的算法，从根节点开始，计算左右两边树的深度相差是否超过 1，如果超过 1，那么不是平衡二叉树；如果没有超过1，那么继续遍历其左右两个子数，直至遍历完成：59.58% 1234567891011121314151617def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ if root is None: return True if abs(self.depth(root.left) - self.depth(root.right)) &lt;= 1: return self.isBalanced(root.left) and self.isBalanced(root.right) return Falsedef depth(self, tree): result, stack = 0, [tree] while tree and stack: result += 1 LRpair = [(node.left, node.right) for node in stack] stack = [leaf for LR in LRpair for leaf in LR if leaf] return result 前一种方法是从上往下搜索，效率不高；从下往上搜索的话效率更高：76.95% 1234567891011121314151617def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ return -1 != self.dfsHeight(root) def dfsHeight(self, root): if root is None: return 0 left = self.dfsHeight(root.left) if left == -1: return -1 right = self.dfsHeight(root.right) if right == -1: return -1 if abs(left - right) &gt; 1: return -1 return 1 + max(left, right) Minimum Depth of Binary Tree (#111)Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 从下往上，如果 left 或者 right 为 0，那么表示那个树枝上没有叶结点，因此不应该进行计算，而直接将另外一边的值加 1 得到其父节点的深度：63.39% 1234567891011def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if root is None: return 0 left = self.minDepth(root.left) right = self.minDepth(root.right) if left == 0: return 1 + right if right == 0: return 1 + left return 1 + min(left, right) 上面的方法可以写成下面三行：31.86% 12345678def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 d = map(self.minDepth, (root.left, root.right)) return 1 + (min(d) or max(d)) Path Sum (#112)Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example:Given the below binary tree and sum = 22,1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. DFS。首先计算每一条路径上数的和，如果一样，那么返回 True。其中，要判断该节点是否是叶节点，如果不是叶子节点，将其加入到堆栈的时候需要判断其是否非 None：18.74% 12345678910111213141516171819202122def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ stack = [root] suml = [0] result = 0 while root and stack: node = stack.pop(0) result = suml.pop(0) + node.val if node.left is None and node.right is None: if result == sum: return True if not node.left is None: suml.insert(0,result) stack.insert(0,node.left) if not node.right is None: suml.insert(0,result) stack.insert(0,node.right) return False 递归。每个节点，递归地判断两边的子节点是否有路径长度为 总和-自身值 大小的路径：52.58% 123456789101112def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False if not root.left and not root.right and root.val == sum: return True sum -= root.val return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum) 未完，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2017/01/21/Leetcode-Python-Solution-Part3/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本站 ss 服务的邀请码]]></title>
      <url>%2F2017%2F01%2F17%2Fss%2F</url>
      <content type="text"><![CDATA[平时不免需要纠正上网姿势，于是用 Vultr 搭建了一个科学上网的 shadowsocks 服务，节点在日本，速度很快。点击 扶墙 了解更多。 放几个邀请码，有需求的朋友可以使用邀请码先注册，然后 邮件 告诉我 用户名，我会帮你预充一些流量（5GB）和余额（30￥），自行兑换合适的套餐。 以下是兑换码： ljw1MjgyMGNkMGZlNjQ2ZDM4YmM ljwkZjIxNjZkZDQyNGE1NzEyNzQ ljwNTI4NDVlYzBhMzc4Mzk0MDAz ljwxZTRiYmQ2MzkzYzkxMTFlNjU ljwdlZTZmNWY5YWE1Y2QxN2NhMW ljwkNDhhYjMxZDAxNmZmY2JmMzM ljwZDFiMmRiNTRkNTViYzhiYmEy ljwRjODA1MWNmZDRlOWVhODA3Mm ljwY5OGQ1Njk2N2Q5NDY0NzFhZj ljwIzZGUwZDRlYWNiOWEzZTZlNT Enjoy~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Leetcode 题解 in Python (2)]]></title>
      <url>%2F2017%2F01%2F11%2FLeetcode-Python-Solution-Part2%2F</url>
      <content type="text"><![CDATA[接上篇。 Part 2 如期而至，其中有好好几道链表的题（用双指针有时候会很方便），涉及到算法效率的问题（用迭代虽然方便，但是对于计算来说效率是很低)，以及分析后变为斐波那契数列求解的问题。题目变得越来越有趣，希望自己可以坚持下去。 Swap Nodes in Pairs (#24)Given a linked list, swap every two adjacent nodes and return its head.For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 利用递归不停地将下两个数交换位置：22.61% 123456789101112131415161718192021222324252627282930313233343536class ListNode(object): def __init__(self, x): self.val = x self.next = Nonedef swap(l): if l == None: return l elif l.next == None: return l else: ln = l.next temp = l.next.next l.next.next = l l.next = temp return lnclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head:return head if not head.next:return head l1 = head l2 = head.next temp = ListNode(0) ret = temp while l1 and l2: temp.next = swap(l1) temp = l1 l1 = l1.next if not l1:break l2 = l1.next return ret.next 将 pre -&gt; a -&gt; b -&gt; b.next 变成 pre -&gt; b -&gt; a -&gt; b.next：51.05% MARK：连续赋值、动态语言123456789101112def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next 注意，Python中的属性可以动态添加，即 self.next 是后来添加的属性。另外，Python中多个变量连续赋值的时候，是一下子将等号右边的数读取进来，不会再随着变量值的改变而改变，然后赋给左边的变量：123456a = 1b = 2a,b = b,a# a = 2, b = 1# 而不是 a = 2, b = 2 Remove Duplicates from Sorted Array (#26)Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory.For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 每发现一个相同的值，将其移到最后，然后后面的值依次向前补充，直到循环过每个值：无法通过测试，效率太低，所有数向前挪这一步不需要进行 12345678910111213141516171819202122def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if nums == []:return 0 last = nums[0] i = c = count = 1 while c &lt; len(nums): this = nums[i] if this == last: for j in range(i,len(nums)-1): nums[j] = nums[j+1] nums[len(nums)-1] = this elif this &lt; last: return count else: count +=1 i += 1 last = this c += 1 return count 将不同的数替换相同数对应位置上的数字，然后返回对应长度的数组：58.91% MARK：双指针12345678910111213141516def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return 0 newTail = 0 for i in range(1, len(nums)): if nums[i] != nums[newTail]: newTail += 1 nums[newTail] = nums[i] return newTail + 1 Remove Element (#27)Given an array and a value, remove all instances of that value in place and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.Example:Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. Hint Try two pointers. Did you use the property of “the order of elements can be changed”? What happens when the elements to remove are rare? 在数组里的数，一个一个和 val 比较，如果不相同，则从数组头部开始加入，最后返回数组的长度（与 #26 类似）：35.64% 123456789101112def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ newlen = 0 for i in range(len(nums)): if nums[i] != val: nums[newlen] = nums[i] newlen += 1 return newlen 如果需要取出的数在数组中很稀少，那么可以通过减小数组长度的方法来提高速度，但是这样的数组的顺序是乱的：35.64% 123456789101112131415def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ i = 0 n = len(nums) while i &lt; n: if nums[i] == val: nums[i] = nums[n-1] n -= 1 else: i += 1 return n Implement strStr() (#28)Implement strStr().Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 首先找出特殊情况；对于一般情况，先查找第一个字符符合的 index，然后检验 len(needle) 个字符是否也一样，注意中间有一步需要判断 haystack 剩下的长度是否不小于 needle 的长度，否则会数组越界：22.46% 1234567891011121314151617181920def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ if needle == "": return 0 if len(needle)&gt;len(haystack): return -1 n0 = needle[0] for index in range(len(haystack)): has = False if haystack[index] == n0: has = True # 检查剩余长度，否则越界 if len(haystack)-index&lt;len(needle):return -1 for i in range(1, len(needle)): if not needle[i] == haystack[index+i]: has = False if has: return index return -1 使用切片来判断字符串是否相等，循环条件需要判断长度：38.69% 12345678910def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ for i in range(len(haystack) - len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 Valid Sudoku (#36)Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. NoteA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 分三种情况检验是否合法（利用一个函数），行、列、以及九宫格内，1-9 每个数字最多只能出现一次：21.52% 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def isValidEachNine(self, eachList): before = list(filter(lambda x:x!='.',eachList)) after = set(before) if len(before) == len(after): return True else: return False def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ # 检查行 for i in range(len(board)): if not self.isValidEachNine(board[i]): return False # 检查列 for index in range(9): l = [] for i in range(len(board)): l.append(board[i][index]) if not self.isValidEachNine(l): return False # 检查九宫格 for rowiter in range(0,9,3): row = rowiter for coliter in range(0,9,3): col = coliter l = [] for rownum in range(3): for colnum in range(3): l.append(board[row+rownum][col+colnum]) if not self.isValidEachNine(l): return False # 都满足 return True 利用set去除相同元组来检测，(c, i)记录每个数字及其行号，(j, c)用来记录每个数字及其列号，(i//3, j//3, c)用来记录每个数字所属九宫格的行列号，(c, i)和(j, c)元组之所以顺序相反，是为了区分行和列，因为c是字符，i和j是整数：67.23% MARK：元组以及生成器的使用123456def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i//3, j//3, c)] for i, row in enumerate(board) for j, c in enumerate(row) if c != '.'), []) return len(seen) == len(set(seen)) Count and Say (#38)The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, ...1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211.Given an integer n, generate the nth sequence. NOTEThe sequence of integers will be represented as a string. 首先处理特殊情况，对于一般情况 (n&gt;1) 来说，每次循环上一次得到的字符串，特别处理一下当这个字符串是最后一个字符串的时候，需要添加进新的字符串中：14.21% 123456789101112131415161718192021222324252627def countAndSay(self, n): """ :type n: int :rtype: str """ if n&lt;1: return "" elif n==1: return "1" result = "1" newresult = "" for iternum in range(n-1): newresult = "" count = 0 last = result[0] for index in range(len(result)): c = result[index] if c == last: count += 1 else: newresult += "%d%s"%(count,last) count = 1 last = c # 最后一个字符串 if index == len(result) - 1: newresult += "%d%s"%(count,c) result = newresult return newresult 上面算法的改写，因为最后一个字符的结果总是没有添加，因此可以在循环外面加入，循环内部可以不需要 index 来判断是否是最后一个字符：47.21% 123456789101112131415161718def countAndSay(self, n): """ :type n: int :rtype: str """ s = '1' for _ in range(n-1): let, temp, count = s[0], '', 0 for l in s: if let == l: count += 1 else: temp += str(count)+let let = l count = 1 temp += str(count)+let s = temp return s Length of Last Word (#58)Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string.If the last word does not exist, return 0. NOTEA word is defined as a character sequence consists of non-space characters only. For example, Given s = &quot;Hello World&quot;, return 5. 以 空格 为分隔符进行切割，去除切割后的最后一个元素，注意可能是空的情况，如果是空，则依次向前取一个：30.29% 12345678910111213def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if s=="": return 0 l = s.split(" ") if len(l) == 0: return -1 else: for index in range(len(l)): if not l[-1-index] == "": return len(l[-1-index]) return 0 一行代码，不具有参考性，利用了Python中字符串的一些方法：43.73% 123456def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ return len(s.rstrip(' ').split(' ')[-1]) 不使用内置的方法解，利用双指针，slow 指向从后往前第一个非空格，fast 指向从 slow 往前第一个空格，两者之差就是长度：62.59% MARK：双指针应用12345678910111213141516def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ ls = len(s) # slow and fast pointers slow = -1 # iterate over trailing spaces while slow &gt;= -ls and s[slow] == ' ': slow-=1 fast = slow # iterate over last word while fast &gt;= -ls and s[fast] != ' ': fast-=1 return slow - fast Plus One (#66)Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.You may assume the integer do not contain any leading zero, except the number 0 itself.The digits are stored such that the most significant digit is at the head of the list. 题意：题目要求是给定一个装有int类型元素的数组，对这个数组加1，然后返回加1的结果。例如，给定[3]，输出[4]；给定[9]，输出[1,0]；给定[9,9]，输出[1,0,0]。 先将 list 变成 int 类型的数字，然后以 int 为基础进行 +1 操作，然后将 int 在转化为 list，且其中每个元素也是 int：64.68% 123456789101112def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ int_val = 0 for i in range(len(digits)): int_val = 10*int_val + digits[i] new_val = int_val + 1 return list(map(int, str(new_val))) # 最后一句亦可以改写成 return [int(i) for i in str(new_val)] 不将 list 转为 int，直接对 list 进行操作，特殊判断末位为9，考虑需要进位（可能不止一位）：47.29% 1234567891011def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ for i in range(len(digits)-1, -1, -1): digits[i] = digits[i] + 1 if digits[i] &lt; 9 else 0 if digits[i]: return digits digits.insert(0, 1) return digits Add Binary (#67)Given two binary strings, return their sum (also a binary string).For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 两个字符串从最后一位开始相加，当两个字符串长度不同时，将剩余长度的字符串与进位标志位相加，然后不断递归调用：36.56% 1234567891011121314151617181920212223242526272829303132333435def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ if not a: return b if not b: return a lplus = 0 result = "" for i in range(-1, -min(len(a),len(b))-1, -1): if a[i] == '1' and b[i] == '1': result = str(lplus) + result lplus = 1 elif a[i] == '0' and b[i] == '0': result = str(lplus) + result lplus = 0 else: if lplus: result = '0' + result lplus = 1 else: result = '1' + result lplus = 0 m = len(a) - len(b) if m &lt; 0: left = b[:-m] elif m &gt; 0: left = a[:m] else: if lplus: return str(lplus) + result else: return result return self.addBinary(left,str(lplus)) + result 直接使用递归，分三种情况考虑，但递归效率较低：22.13% MARK：递归123456789def addBinary(self, a, b): if len(a)==0: return b if len(b)==0: return a if a[-1] == '1' and b[-1] == '1': return self.addBinary(self.addBinary(a[0:-1],b[0:-1]),'1')+'0' if a[-1] == '0' and b[-1] == '0': return self.addBinary(a[0:-1],b[0:-1])+'0' else: return self.addBinary(a[0:-1],b[0:-1])+'1' Climbing Stairs (#70)You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? NOTEGiven n will be a positive integer. 使用递归的方法，每次爬楼梯的最后一步都可以选择1步或2步，如果选择1步，那么为 n-1 层的方法数；如果选择2步，那么为 n-2 层的方法数，两者相加就是总的方法数：无法通过测试，效率太低 123456789def climbStairs(self, n): """ :type n: int :rtype: int """ if n&lt;=0: return 0 elif n==1: return 1 elif n==2: return 2 return self.climbStairs(n-2)+self.climbStairs(n-1) 将前面的方法改写成使用循环：53.54% 12345678910111213141516def climbStairs(self, n): """ :type n: int :rtype: int """ if n&lt;=0: return 0 elif n==1: return 1 elif n==2: return 2 inall = 0 onestepway = 2 twostepway = 1 for numiter in range(n-2): inall = onestepway + twostepway twostepway = onestepway onestepway = inall return inall 其实问题的解是一个 斐波那契(fibonacci)数列 求解问题，因为每一步的值等于前一个值加上前前个的值：66.03% MARK：斐波那契数列 fibonacci123456789def climbStairs(self, n): """ :type n: int :rtype: int """ a = b = 1 for _ in range(n): a, b = b, a + b return a 未完，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2017/01/11/Leetcode-Python-Solution-Part2/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Leetcode 题解 in Python (1)]]></title>
      <url>%2F2017%2F01%2F01%2FLeetcode-Python-Solution-Part1%2F</url>
      <content type="text"><![CDATA[2017年了，给自己 订个目标 开个坑吧，一天一条 Leetcode 的算法题，把解题过程中自己的方法和大神的一些思路做个记录，希望能有所提高。先从 Easy 开始，十条一发，欢迎督促。如果有更好的解题思路，欢迎一起交流。 思路后面的百分数代表 Leetcode 提供的算法效率击败的人数百分比，这个数值摇摆不定且浮动较大，仅供参考。算法效率优劣参考时间和空间复杂度，本文并不涉及。 Two Sum (#1)Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. The return format had been changed to zero-based indices. 通过循环：41.25% 123456789101112def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ for i in range(len(nums)): j = i while j&lt; len(nums)-1: j = j+1 if nums[i]+nums[j] == target: return [i,j] 通过list：43.32% 123456789101112def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ for i in range(len(nums)): j = target-nums[i] if j in nums: index = nums.index(j) if i != index: return [i, nums.index(j)] 通过dict：43.38% 12345678910111213def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dict = &#123;&#125; for i in range(len(nums)): rest = target - nums[i] if rest in dict: return [dict.get(rest),i] else: dict[nums[i]] = i ZigZag Conversion (#6)The string “PAYPALISHIRING“ is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR“。 寻找每行下标规律，使用一个list按行序读入对应文字，最后统一输出：30.49% 12345678910111213141516171819202122232425262728293031323334def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ lists = list(s) newl = [] num = len(s) if num==0 or numRows==1: return s repeat = (numRows-1) * 2 numrepeat = (num+repeat-1) // repeat for row in range(numRows): if row == 0: numCols = numrepeat for col in range(numCols): newl.append(lists[col*repeat]) elif row == numRows-1: numCols = numrepeat for col in range(numCols): index = row + col*repeat if (index &lt; num): newl.append(lists[index]) else: for n in range(numrepeat): first = row + n * repeat second = (2*n+1)*repeat - first if (first &lt; num): newl.append(lists[first]) if (second &lt; num): newl.append(lists[second]) return ''.join(newl) 每行建立一个字符串，按顺序读取，然后将其放到对应行的字符串中，最后统一输出：93.99% 123456789101112131415161718192021def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1 or numRows &gt;= len(s): return s L = [''] * numRows index, step = 0, 1 for x in s: L[index] += x if index == 0: step = 1 elif index == numRows -1: step = -1 index += step return ''.join(L) Reverse Integer (#7)Reverse digits of an integer.Example1: x = 123, return 321Example2: x = -123, return -321 NOTEIf the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 将int转换成list，然后使用切片方法进行倒排，排除符号，然后变换成int类型，判断是否溢出，最后输出：63.11% 12345678910111213141516171819def reverse(self, x): """ :type x: int :rtype: int """ if x&gt;0: result = int(''.join(list(str(x))[::-1])) if result&lt; 2**31: return result else: return 0 elif x&lt;0: result = -int(''.join(list(str(x))[:0:-1])) if -result&lt; 2**31: return result else: return 0 else: return 0 利用算法输出一个整数的反序：69.19% MARK：求一个整数的反序数123456789101112131415161718def reverse(self, x): """ :type x: int :rtype: int """ if abs(x) &gt;= 2147483647: return 0 result = 0 pos_x = abs(x) while pos_x: result = result * 10 + pos_x % 10 pos_x //= 10 if result &gt;= 2147483647: return 0 return result if x &gt;= 0 else result * (-1) String to Integer (#8)Implement atoi to convert a string to an integer. NOTEThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 先对字符串处理，然后将字符串转换成整型，特别注意对于对于正数、负数以及非数字的情况：19.07% 12345678910111213141516171819202122232425262728293031323334353637def myAtoi(self, mystr): """ :type str: str :rtype: int """ nstr = mystr.strip() flag = 1 result = 0 hasFlag = False isFirst = True def check(result): if result &gt; 2**31 -1: return 2**31 -1 elif result &lt; -2**31: return -2**31 else: return result for s in nstr: if s in [str(t) for t in range(10)]: result = result * 10 + int(s) isFirst = False elif s == '-' and isFirst: if hasFlag: return 0 else: flag = -1 hasFlag = True elif s == '+' and isFirst: if hasFlag: return 0 else: flag = 1 hasFlag = True else: return check(result * flag) result = result * flag return check(result) 利用正则表达式筛选数字：55.36% 12345678910111213141516def atoi(self, str): str = str.strip() str = re.findall('(^[\+\-0]*\d+)\D*', str) try: result = int(''.join(str)) MAX_INT = 2147483647 MIN_INT = -2147483648 if result &gt; MAX_INT &gt; 0: return MAX_INT elif result &lt; MIN_INT &lt; 0: return MIN_INT else: return result except: return 0 Palindrome Number (#9)Determine whether an integer is a palindrome. Do this without extra space. NOTECould negative integers be palindromes? (ie, -1)If you are thinking of converting the integer to string, note the restriction of using extra space.You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? 依次验证首尾数字是否相同来判断，负数均不是：56.29% 1234567891011121314151617def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False n = 0 r = x while r &gt; 0: n += 1 r = x // 10**n while n &gt; 1: if x // 10**(n-1) != x % 10: return False x = (x%10**(n-1))//10 n -= 2 return True 先考虑明显不可能的情况，然后将输入的整数拆成前半部分和后半部分，对于奇数位和偶数位分别考虑： 88.84% 123456789101112def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0 or (x!=0 and x%10 ==0): return False rev = 0 while x&gt;rev: rev = rev*10 + x%10 x = x//10 return x==rev or x==rev//10 Roman to Integer (#13)Given a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999. 罗马数字中 Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000），从大（M）到小（I）开始寻找，然后在该数字左边的减去、右边的加上：5.35% 123456789101112131415161718192021222324252627282930313233343536def restValue(subs,indexStr,index): indexDict = &#123;'M':1000,'D':500,'C':100,'L':50,'X':10,'V':5,'I':1&#125; indexValue = indexDict[indexStr] left = subs[:index] leftValue = compute(left) if left else 0 right = subs[index+1:] rightValue = compute(right) if right else 0 return indexValue+rightValue-leftValuedef compute(subs): if not subs: return 0 indexM = subs.find("M") indexD = subs.find("D") indexC = subs.find("C") indexL = subs.find("L") indexX = subs.find("X") indexV = subs.find("V") indexI = subs.find("I") if not indexM == -1: return restValue(subs,'M',indexM) elif not indexD == -1: return restValue(subs,'D',indexD) elif not indexC == -1: return restValue(subs,'C',indexC) elif not indexL == -1: return restValue(subs,'L',indexL) elif not indexX == -1: return restValue(subs,'X',indexX) elif not indexV == -1: return restValue(subs,'V',indexV) elif not indexI == -1: return restValue(subs,'I',indexI) return compute(s) 观察罗马数字的构成，发现：最右一位总是加上的，除此之外，如果某一位比其右边一位表示的数小，那么就减去，否则加上：58.32% 12345678910111213def romanToInt(self, s): """ :type s: str :rtype: int """ roman = &#123;'M': 1000,'D': 500 ,'C': 100,'L': 50,'X': 10,'V': 5,'I': 1&#125; z = 0 for i in range(0, len(s) - 1): if roman[s[i]] &lt; roman[s[i+1]]: z -= roman[s[i]] else: z += roman[s[i]] return z + roman[s[-1]] Longest Common Prefix (#14)Write a function to find the longest common prefix string amongst an array of strings. 用一个最大相同前缀的index记录，通过循环找到最大的index： 57.73% 12345678910111213141516171819def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return "" count = min(list(map(len,strs))) end = False maxindex = 0 for i in range(count): base = strs[0][i] for j in range(1,len(strs)): if not strs[j][i] == base: end = True break if end: break maxindex +=1 return strs[0][:maxindex] 使用二分法，先查找一半中的前半段，如果是LCP，那么后面的最大index向后一位；如果不是LCP，那么最小index向前一位，直到找到最大LCP： 57.73% 12345678910111213141516171819def isCommonPrefix(self, strs, slen): str1 = strs[0][:slen] for i in range(1,len(strs)): if not strs[i][:slen] == str1: return False return Truedef longestCommonPrefix(self, strs): if len(strs) == 0: return "" minLen = min(list(map(len,strs))) low = 1 high = minLen while low&lt;=high: middle = (low + high) // 2 if self.isCommonPrefix(strs,middle): low = middle +1 else: high = middle -1 return strs[0][:(low+high)//2] Remove Nth Node From End of List (#19)Given a linked list, remove the nth node from the end of list and return its head.For example,123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 因为是找出后n个数并删掉，而每个链表只记录的它下一个指向的数，因此首先要求出列表中总的个数，然后计算要删去的数在正向的第几个：54.06% 123456789101112131415161718192021222324252627282930313233class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ p =head num = 1 while p.next: p = p.next num +=1 index = num - n+1 #from 1 if index == 1: return head.next pp = head i = 1 while True: p = pp pp = pp.next i +=1 if i == index: if pp.next: p.next = pp.next else: p.next = None break return head 使用两个指针，两个指正中间的距离相聚为传入的n，即倒数第n个要删除的数，然后两个指针同时向前，直到后面的指正到达链表最后，而前面的指向的刚好是要删除的节点的前一个节点：67.78% 123456789101112class Solution: def removeNthFromEnd(self, head, n): fast = slow = head for _ in range(n): fast = fast.next if not fast: return head.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head Valid Parentheses (#20)Given a string containing just the characters&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. 利用一个list来存放对应应该出现的记号，并且按顺序出现，如果不是按照list中先进后出的顺序出现，那么标记为False：46.62% 1234567891011121314151617181920212223242526def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] l = list(s) for i in range(len(l)): if l[i] == "(": stack.append(")") elif l[i] == "&#123;": stack.append("&#125;") elif l[i] == "[": stack.append("]") elif l[i] == ")": if len(stack) == 0 or stack.pop() != ")": return False elif l[i] == "&#125;": if len(stack) == 0 or stack.pop() != "&#125;": return False elif l[i] == "]": if len(stack) == 0 or stack.pop() != "]": return False if not len(stack) == 0: return False return True 上面的方法可以写成下面的形式（字典的运用），代码更简洁：24.68% 123456789101112def isValid(self, s): stack = [] dict = &#123;"]":"[", "&#125;":"&#123;", ")":"("&#125; for char in s: if char in dict.values(): stack.append(char) elif char in dict.keys(): if stack == [] or dict[char] != stack.pop(): return False else: return False return stack == [] Merge Two Sorted Lists (#21)Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 比较两个ListNode的值，哪个大将新的ListNode指向哪个，然后将取过值得ListNode的指针指向后一个，即next，再次比较。考虑有一个没有取完的情况 ：77.19% 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 == []: return l2 if l2 == []: return l1 l = ListNode(0) lptr = l p = ListNode(0) l1_temp = l1 l2_temp = l2 while l1_temp!= None and l2_temp != None: if l1_temp.val &lt; l2_temp.val: p = l1_temp l1_temp = l1_temp.next else: p = l2_temp l2_temp = l2_temp.next lptr.next = p lptr= p if l1_temp != None: lptr.next = l1_temp if l2_temp != None: lptr.next = l2_temp return l.next 上面一种方法可以简写成： 43.81% 123456789101112def mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return dummy.next 使用递归调用的方法：50.10% 123456789def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 和第一种方法类似，不同的是将两个list连接成一个，然后再一次检查每一个是否是按照从小到大的顺序排列：52.80% 123456789101112131415161718# in-place, iteratively def mergeTwoLists(self, l1, l2): if None in (l1, l2): return l1 or l2 dummy = cur = ListNode(0) dummy.next = l1 while l1 and l2: if l1.val &lt; l2.val: l1 = l1.next else: nxt = cur.next cur.next = l2 tmp = l2.next l2.next = nxt l2 = tmp cur = cur.next cur.next = l1 or l2 return dummy.next 未完，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2017/01/01/Leetcode-Python-Solution-Part1/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Coursera - Scala 函数式程序设计原理 - 学习笔记 (2)]]></title>
      <url>%2F2016%2F12%2F23%2FCoursera-FP-in-Scala-Note-Part2%2F</url>
      <content type="text"><![CDATA[此笔记是在学习 Coursera 上 Functional Programming Principles in Scala 课程时所整理，方便今后查阅。 接上篇。 Types and Pattern MatchingObjects Everywhere 无处不在的对象Scala是纯面向对象的语言，因此在Scala中，所有的值都是对象。虽然第一眼看上去，Scala中存在一些不是对象的，如基本类型，函数等，但是基本类型Boolean、Int等都可以自己定义类型，因此它们也是对象。Scala和Java一样，支持重载overlaod机制，可以根据方法传入的不同参数选择应该调用哪个具体的方法。 Functions as Objects 函数作为对象在Scala中，函数也被看作是对象，而函数的类型A =&gt; B也只是scala.Function1[A, B]的缩写，且定义如下：1234package scalatrait Function1[A, B] &#123; def apply(x: A): B&#125; 而Function2接收2个参数，Function3接收3个参数，最多至22个参数。函数值的扩展：12345678910111213(x: Int) =&gt; x * x// 扩展为&#123; class AnonFun extends Function1[Int, Int] &#123; def apply(x: Int) = x * x &#125; new AnonFun&#125;// 或者，使用匿名函数简写new Function1[Int, Int] &#123; def apply(x: Int) = x * x&#125; 调用时，f(a, b)函数调用，其中f是类型的名称，可以扩展成f.apply(a, b)。12345678val f = (x: Int) =&gt; x * xf(7)// 写成val f = new Function1[Int, Int] &#123; def apply(x: Int) = x * x&#125;f.apply(7) 注意，方法本身不是一个函数值，例如：1def f(x: Int): Boolean = ... 但是，当方法被用在需要接受一个函数值的地方时，它会自动转化成函数值。123456(x: Int) =&gt; f(x)// 展开new Function1[Int, Boolean] &#123; def apply(x: Int) = f(x)&#125; Subtyping and Generics 子类型化和泛型类型边界type boundassertAllPos当接收空数组时返回空数组，当接收非空数组时，返回非空数组，可以通过下面的方式表示：1def assertAllPos[S&lt;: IntSet](r: S): S = ... &lt;:意味着它是类型参数S的上界upper bound，S可以使服从IntSet累的所有类型，也就是说 S &lt;: T S是T的子类型 S &gt;: T S是T的父类型，或者说，T是S的子类型 &gt;:意味着下界lower bound，例如[S&gt;: NonEmpty]中，S可以使NonEmpty, IntSet, AnyRef 或者是Any。可以同时使用上界和下界组成混合边界mixed bound，例如[S:&gt; NonEmpty &lt;: IntSet]，会限制S的类型在NonEmpty和IntSet之间。协变量covariance如果NonEmpty:&lt; IntSet，那么List[NonEmpty]&lt;: List[IntSet]成立，但并不是任何时候都是成立的，当满足下面条件时：如果A&lt;: B，那么可以对B做的任何事情都可以对A做。 Let q(x) be a property provable about objects x of type B. Then q(y) should be provable for objects y of type A where A &lt;: B. 1234567val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))val b: Array[IntSet] = ab(0) = Emptyval s: NonEmpty = a(0)// Scala中编译器会在第2行报错，因为Scala中Array不是协变量// 若使用Java语法改写，那么Java编译时不会报错，但是在第3行会有运行时错误，抛出异常 VarianceDecomposition 分解类型检验type test1def isInstanceOf[T]: Boolean // 检验对象的类型是否符合T 类型转换type cast1def asInstanceOf[T]: T // 将对象当做是类型T，如果不是，抛出ClassCastException 例如：123456def eval(e: Expr): Int = if (e.isInstanceOf[Number]) e.asInstanceOf[Number].numValue else if (e.isInstanceOf[Sum]) eval(e.asInstanceOf[Sum].leftOp) + eval(e.asInstanceOf[Sum].rightOp) else throw new Error("Unknown expression" + e) 但是类型转换会存在一些未知的问题，因此不建议使用。我们可以通过在类中定义一个eval方法，并且由子类改写来解决这个问题：123456789trait Expr &#123; def eval: Int&#125;class Number(n: Int) extends Expr &#123; def eval: Int = n&#125;class Sum(e1: Expr, e2: Expr) extends Expr &#123; def eval: Int = e1.eval + e2.eval&#125; 但是，当对表达式进行简化的时候，比如说a\*b+a\*c -&gt; a\*(b+c)时，就不能只在某一个类中增加来进行计算了。 Pattern Matching 模式匹配使用模式匹配来进行函数式分解，在Scala中使用样本类case class来实现，case class的定义和普通类一样，但是以标识符case开头，如：123trait Exprcase class Number(n: Int) extends Exprcase class Sum(e1: Expr, e2: Expr) extends Expr 并且，它同时隐式地定义了拥有apply方法的伴随对象companion object。123456object Number &#123; def apply(n: Int) = new Number(n)&#125;object Sum &#123; def apply(e1: Expr, e2: Expr) = new Sum(e1, e2)&#125; 因此，可以使用Number(1)而不用写new Number(1)来创建。模式匹配pattern matching是C和Java中switch的一般化，并且使用match关键字：1234def eval(e: Expr): Int = e match &#123; case Number(n) =&gt; n case Sum(e1, e2) =&gt; eval(e1) + eval(e2)&#125; 规则：12345678910e match &#123; case pat1 =&gt; expr1 ... case patn =&gt; exprn&#125;// e是选择子，被选择来进行模式匹配的// pat是模式// expr是表达式// 当没有模式可以匹配选择子的值的时候，MatchError异常将会抛出 模式可以由下面几部分构成： 构造器：Number, Sum 变量：n, e1, e2 通配符：_ 常量：1, true 其中，变量总是以小写字母开头，并且相同的变量名只能在模式中出现一次， 如Sum(x, x)是不合法的。常量的名字是以大写字母开头，除了保留关键字null, true, false。12345678910111213141516171819202122eval(Sum(Number(1), Number(2)))→Sum(Number(1), Number(2)) match &#123; case Number(n) =&gt; n case Sum(e1, e2) =&gt; eval(e1) + eval(e2)&#125;→eval(Number(1)) + eval(Number(2))→Number(1) match &#123; case Number(n) =&gt; n case Sum(e1, e2) =&gt; eval(e1) + eval(e2)&#125; + eval(Number(2))→1 + eval(Number(2))→→3 当然，可以将模式匹配定义为方法：123456trait Expr &#123; def eval: Int = this match &#123; case Number(n) =&gt; n case Sum(e1, e2) =&gt; e1.eval +e2.eval &#125;&#125; 和上一节的方法相比，如果以后会更多地新建类，那么建议使用上一节的改进方法，因为新的类只需定义def eval方法，其他的都不需要改动；而如果以后会更多地添加方法，那么应该使用模式匹配，因为只需要在基本类中定义一个模式匹配的方法，就能够匹配所有的情况，不需要在其他类中一一添加。 Lists1234val fruit = List("apples", "oranges", "pears") // List[String]val nums = List(1, 2, 3, 4) // List[Int]val diag3 = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1)) // List[List[Int]]val empty = List() // List[Nothing] list和array有两个重要的不同点： list是不可变的，list总的元素是不可改变的 list是递归的，而array是平的（不可递归） list中的元素必须是同性质的，也就是所有的元素都使相同的类型，因此，类型T元素的list可以写作List[T]。上面list的构造方法属于语法糖，同样可以通过构造器::来构造，x :: xs表示第一个元素是x，接下去的元素为xs。123fruit = "apple" :: ("oranges" :: ("pears" :: Nil))nums = 1 :: (2 :: (3 :: (4 :: Nil)))empty = Nil Scala中，以:结尾的操作符都是右结合，例如A :: B :: C看成是A :: (B :: C)，因此可以减少定义中多余的括号。并且，这些操作符调用方法的时候是对操作符右边的操作数进行调用。12val nums = 1 :: 2 :: 3 :: 4 :: NilNil.::(4).::(3).::(2).::(1) list模式匹配： Nil：常量Nil p :: ps：head是p，tail是ps的list List(p1, …, pn)：相当于p1 :: … :: pn :: Nil 123451 :: 2 :: xs // 以1，2开始x :: Nil // 长度为1List(x) // 与x :: Nil一样List() // 空list，与Nil一样List(2 :: xs) // 只包含一个以2开始的list的list ListsMore Functions on Lists 更多List的函数list的方法 xs.length xs.last xs.init：返回包含xs除最后一个元素外剩余所有元素的list，如果为空则抛出异常。 xs take n：返回包含xs前n个元素的list，如果长度小于n那么返回它自己 xs drop n：返回去除n个元素的剩余部分 xs(n)：或者写成xs apply n，返回xs的n（从0开始）位的元素 创建新的list xs ++ ys：返回包含xs所有元素，后面跟着ys所有元素的list xs.reverse：返回倒序的list xs updated(n, x)：返回和原list相同的list，只将第n位的数改成x 寻找元素 xs indexOf x：xs中第一个元素与x匹配的序号，如果没有返回-1 xs contains x：与xs indexOf x &gt;= 0相同 Pairs and Tuplespair由x、y写成(x, y)组成，如下：1val pair = ("answer", 42) pair也可以被用作模式匹配中的模式：1val (label, value) = pair tupletuple的类型(T1, …, Tn)是scala.Tuplen[T1, …, Tn]的缩写，tuple表达式(e1, …, en)相当于scala.Tuplen(e1, …, en)，tuple模式(p1, …, pn)相当于scala.Tuplen(p1, …, pn)。可以通过下划线_1, _2来获得tuple中的值，如：12val label = pair._1val value = pair._2 Implicit Parameters 隐式参数12345678910def msort[T](xs: List[T])(implicit ord: Ordering) = def merge(xs: List[T], ys: List[T]) = ... if (ord.lt(x, y)) ... ... merge(msort(fst), msort(snd)) ...// call msort can avoid the ordering parametermsort(nums)msort(fruits) 在参数名前加标识符implicit，可以将该参数声明为隐式参数，这样的参数不需要具体传入，编译器会根据传入变量的类型自动选取。使用隐式参数的规则：编译器会搜索隐式定义，被标记为implicit、类型与T相匹配、在函数调用处可见或者被定义在与T相关的伴随对象中。如果编译器找到了唯一的定义，那么会将实际的参数传递给隐式参数，如果没有或者有多个，那么会报错。 Higher-Order List FunctionsMap123456abstract class List[T] &#123; def map[U](f: T =&gt; U): List[U] = this match &#123; case Nil =&gt; this case x :: xs =&gt; f(x) :: xs.map(f) &#125;&#125; filter1234567abstract class List[T] &#123; ... def filter(p: T =&gt; Boolean): List[T] = this match &#123; case Nil =&gt; this case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p) &#125;&#125; filter的变形： xs filterNot p xs partition p xs takewhile p xs dropWhile p xs span p 1234567891011121314151617val nums = List(2, -4, 5, 7, 1)nums filter(x =&gt; x &gt; 0)nums filterNot(x =&gt; x &gt; 0)nums partition(x =&gt; x &gt; 0)nums takeWhile(x =&gt; x &gt; 0)nums dropWhile(x =&gt; x &gt; 0)nums span(x =&gt; x &gt; 0)// res0: List[Int] = List(2, 5, 7, 1)// res1: List[Int] = List(-4)// res2: (List[Int], List[Int]) = (List(2, 5, 7, 1),List(-4))// res3: List[Int] = List(2)// res4: List[Int] = List(-4, 5, 7, 1)// res5: (List[Int], List[Int]) = (List(2),List(-4, 5, 7, 1)) Reduction of ListsreduceLeftreduceLeft在list的元素间插入指定的二元操作符。函数的简写：((x, y) =&gt; x * y)可以简写成(_ * _)，每一个_表示一个从左到右的新的参数。foldLeftfoldLeft和reduceLeft一样，不过多了一个accumulator累加器参数，当空list调用foldLeft参数时会返回这个值。12345678// reduceLeftList(x1, ..., xn) reduceLeft op = (...(x1 op x2) op ...) op xn// foldLeft(List(x1, ..., xn) foldLeft z)(op) = (...(z op x1) op ...) op xn// reduceRightList(x1, ..., x&#123;n-1&#125;, xn) reduceRight op = x1 op (... (x&#123;n-1&#125; op xn) ...)// foldRight(List(x1, ..., xn) foldRight acc)(op) = x1 op (... (xn op acc) ...) Example:12def concat[T](xs: List[T], ys: List[T]): List[T] = (xs foldRight ys)(_ :: _) Reasoning About Concat引用透明referential transparency证明可以随意地对一个推断的某个部分应用归减的方法来替换成相同的部分。这是因为纯函数式程序没有副作用，被替换的部分就等于化简之后的形式。这种原理称为引用透明。 Note that a proof can freely apply reduction steps as equalities to some part of a term.That works because pure functional programs don’t have side effects; so that a term is equivalent to the term to which it reduces.This principle is called referential transparency. 结构归纳法structural induction为了证明P(xs)对所有xs成立，需要证明： P(Nil)成立 对于list xs以及某个元素x，如果P(xs)成立，那么P(x :: xs)也成立 To prove a property P(xs) for all lists xs, show that P(Nil) holds (base case), for a list xs and some element x, show the induction step: if P(xs) holds, then P(x :: xs) also holds. A Larger Equational Proof on ListsCollectionsOther Collectionslists是线性的，获取第一个元素比获取list中间或者结尾的元素要更快。因此，Scala定义了另外一种序列的实现，Vector，其比list更加平均。如果操作是去序列的首个元素以及末尾所有元素，应该使用list来存储；如果操作是对序列中的每个元素进行映射，例如map等操作，则应该使用vector来存储。12val nums = Vector(1, 2, 3, -88)val people = Vector("Bob", "James", "Peter") vector支持list相同的所有操作，除了 :: 操作，vector使用（: 指向的是集合）： x +: xs：创建一个新vector，以x开头，后面跟随xs xs :+ x：创建一个新vector，以xs开头，后面跟随x List和Vector的基类是Seq，它表示所有的序列。数组和字符串支持和Seq一样的操作，因此在需要的时候可以隐式地转换成序列。（它们不是Seq的子类，因此数组和字符串来自Java） 12345val xs = Array(1, 2, 3, 44)xs map (x =&gt; x * 2)val s = "Hello World"s filter (c =&gt; c.isUpper) Range有三个操作符：to（包含），until（不包含），by（确定步长）1234val r: Range = 1 until 5 // 1, 2, 3, 4val s: Range = 1 to 5 // 1, 2, 3, 4, 51 to 10 by 3 // 1, 4, 7, 106 to 1 by -2 // 6, 4, 2 Ranges表示一个带有三个属性的对象，下界、上界、步长。 序列的一些通用操作（List、Vector、Range）：123456789xs exists p // xs中存在p(x)为真，则真xs forall p // xs中所有p(x)为真，则真xs zip ys // 返回xs和ys对应元素组成的pair的序列xs.unzip // 将pair序列分解成两个list，分别包含全部第一个元素和全部第二个元素xs.flatmap f // 将f函数得到的集合的所有的值进行收集，形成新的集合xs.sum // xs所有元素的和xs.product // xs所有元素的乘积xs.max // xs中最大的元素xs.min // xs中最小的元素 Tip123&#123; case p1 =&gt; e1 ... case pn =&gt; en &#125;// 等价于x =&gt; x match &#123; case p1 =&gt; e1 ... case pn =&gt; en &#125; Combinatorial Search and For-Expressions123(1 until n) map(i =&gt; (1 until i) map(j =&gt; (i, j)))// res0: scala.collection.immutable.IndexedSeq[scala.collection.immutable.IndexedSeq[(Int, Int)]] = Vector(Vector(), Vector((2,1)), Vector((3,1), (3,2)), Vector((4,1), (4,2), (4,3)), Vector((5,1), (5,2), (5,3), (5,4)), Vector((6,1), (6,2), (6,3), (6,4), (6,5))) 结果是vector of vectors。因为，1 until n是Range类型，经过map之后不能是Range类型，只能转换成IndexedSeq，并且Vector是IndexedSeq的子类，于是转换成了Vector类型。 一个装有序列的序列，我们把它记做xss(a sequence of sequences)，我们使用foldRight和++来将所有的子序列结合起来。或者，使用内置的方法flatten。1234(xss foldRight Seq[Int]())(_ ++ _)// equivalentlyxss.flatten 定理：1xs flatMap f = (xs map f).flatten For表达式12345case class Person(name: String, age: Int)for (p &lt;- persons if p.age &gt; 20) yield p.name// is equivalent topersons filter (p =&gt; p.age &gt; 20) map (p =&gt; p.name) for (s) yield es是一序列的生成器generator和过滤器filter，e是一个迭代返回的值。generator是这样的形式：p &lt;- e，其中p是一个模式pattern，e是一个集合的表达式。filter是这样的形式：if f，f是一个布尔表达式。序列必须以一个generator开始，如果序列中有多个generator，最后一个generator比第一个generator变化的要更快。我们可以将generator和filter写在一个{ }中，这样可以每一行写一个generator或者filter，而不用加上分号。 Combinatorial Search Example集合SetSet是scala集合中的另一个基本抽象，集合写法类似于序列：12val fruit = Set("apple", "banana", "pear")val s = (1 to 6).toSet 序列上的大部分操作都可以用在集合上：123s map (_ + 2)fruit filter (_.startsWith == "app")s.nonEmpty Set 和 Sequence 的区别： set是无序的，set中元素出现的顺序不是预先定义好的 set没有重复的元素 set上最重要的操作是contains，而seq上重要的操作是head和tail，或者对vector来说的indexing Maps映射MapMap[Key, Value]是将所有Key类型与Value类型将结合的数据结构。12val romanNumerals = Map("I" -&gt; 1, "V" -&gt; 5, "X" -&gt; 10)val capitalOfCountry = Map("US" -&gt; "Washington", "Switzerland" -&gt; "Bern") Map是可迭代的，并且也是函数，Map[Key, Value]的函数类型是Key =&gt; Value，因此map可以使用在任何函数可以使用的地方。如果没有对应的键，会抛出异常，但是可以使用get方法来避免。123capitalOfCountry("US") // "Washington"capitalOfCountry("Andorra") // NoSuchElementException: key not found: AndorracapitalOfCountry get "China" // Option[String] = None Option类型：123trait Option[+A]case class Some[+A](value: A) extends Option[A]object None extends Option[Nothing] 因此，Option类型可以有两种返回值类型： None：找不到匹配的key Some(x)：如果key找到对应value 由于Option是case class，因此可以使用模式匹配来进行分解：1234567def showCapital(country: String) = capitalOfCountry.get(country) match &#123; case Some(capital) =&gt; capital case None =&gt; "missing data"&#125;showCapital("US") // "Washington"showCapital("China") // "missing data" sorted123val fruit = List("apple", "pear", "orange", "pineapple")fruit sortWith (_.length &lt; _.length) // List("pear", "apple", "orange", "pineapple")fruit.sorted // List("apple", "orange", "pear", "pineapple") groupBy1fruit groupBy (_.head) //scala.collection.immutable.Map[Char,List[String]] = Map(p -&gt; List(pear, pineapple), a -&gt; List(apple), o -&gt; List(orange)) 默认值，map只是局部的函数，如果map没有存储对应的key，从map中取得这个key对应的值可能会抛出异常。可以使用withDefaultValue将map变成一个完整的函数。12val cap1 = capitalOfCountry withDefaultValue "&lt;unknown&gt;"cap1("China") // "&lt;unknown&gt;" Putting the Pieces TogetherCourse Conclusion higher-order functions case classes and pattern matching immutable collections absence of mutable state flexible evaluation strategies: strict vs. by name 全文完。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/23/Coursera-FP-in-Scala-Note-Part2/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDFS 常用操作]]></title>
      <url>%2F2016%2F12%2F15%2FHDFS-Commands%2F</url>
      <content type="text"><![CDATA[几种指令区别在操作HDFS上的文件的时候，Hadoop给我们提供了以下三种（其中一种已被废弃）指令，它们分别是： hadoop fs: 适用范围最广，操作通用文件系统，例如Local FS、HDFS、HFTP FS、S3 FS等。 hadoop dfs: 进行与HDFS相关的操作，但是该方法已经被废弃，使用hdfs dfs代替。 hdfs dfs: 进行HDFS的相关操作。 值得注意，如果hadoop fs指令后未指明是何种文件系统，那么默认是HDFS，也就是说hadoop fs -ls /相当于hadoop fs -ls hdfs:///。还有一点，/path路径和path并不指向同一个目录，后者其实是/user/username/path的简写形式。这一点与Linux本地文件系统类似。 几种指令操作类似，下面以hadoop fs为例，介绍常用的几种操作。 FS Shell调用FS Shell指令为：bin/hadoop fs &lt;args&gt;的形式，如果在系统的环境变量的路径中添加了$Hadoop_HOME/bin，那么可以直接使用hadoop fs &lt;args&gt;指令。 常用操作创建文件夹hadoop fs -mkdir &lt;paths&gt;：在HDFS上创建指令路径的目录。12# 在HDFS上新建一个data目录hadoop fs -mkdir /data 上载文件hadoop fs -put &lt;localsrc&gt; ... &lt;dst&gt;：将一个或多个本地文件上载到HDFS目录中。12# 将本地的u1.base和u1.test文件写入到HDFS中的data目录hadoop fs -put /home/linux/Documents/u1.base home/linux/Documents/u1.test /data 下载文件hadoop fs -get &lt;src&gt; &lt;localdst&gt;：复制文件到本地文件系统。123# 将HDFS中u1.base和u1.test复制到本地hadoop fs -get /data/u1.base /home/linux/Documentshadoop fs -get /data/u1.test /home/linux/Documents 复制文件hadoop fs -cp URI [URI …] &lt;dest&gt;：将文件从源路径复制到目的路径。12# 将data目录下的u1.base和u1.test文件复制到/data/ml100k文件夹下hadoop fs -cp /data/u1.base /data/u1.test /data/ml100k 移动文件hadoop fs -mv URI [URI …] &lt;dest&gt;：将文件从源路径移动到目的路径。不允许不同文件系统间移动文件。12# 将data目录下的u1.base和u1.test文件移动到/data/ml100k文件夹下hadoop fs -mv /data/u1.base /data/u1.test /data/ml100k 查看目录结构hadoop fs -ls &lt;args&gt;： 如果是文件：返回文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID 如果是目录：返回目录名 &lt;dir&gt; 修改日期 修改时间 权限 用户ID 组ID 12# 查看data目录下的直接子文件hadoop fs -ls /data 查看文件内容hadoop fs -cat URI [URI …]：将路径指定文件的内容输出到stdout。12# 查看u1.test文件的内容hadoop fs -cat /data/u1.test 删除文件hadoop fs -rm [-R] URI [URI …]：删除指定文件。12# 将data目录下u1.base、u1.testhadoop fs -rm /data/u1.base /data/u1.test 若想要删除文件夹及其路径内所有文件，则使用下面指令：12# 删除/data/ml100k目录下所有文件hadoop fs -rm -R /data/ml100k 读取对于不同的文件系统，有不同的scheme，读取本地文件系统时候，应该使用file:///localpath；而对于HDFS，应该使用hdfs:///hdfspath。HDFS所有节点都可以读取，但是本地文件系统只能够读取本地文件，如果程序需要读本地文件，应该在所有节点的相同目录下都有该文件的备份。 阅读参考： 关于三种指令的区别，参考stackoverflow。 更多指令，参考Hadoop文档ch或en(最新稳定版)。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/15/HDFS-Commands/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[协同过滤推荐之 矩阵分解模型]]></title>
      <url>%2F2016%2F12%2F12%2FCF-MF%2F</url>
      <content type="text"><![CDATA[推荐 SVDSingular Value Decomposition, 奇异值分解 定义 假设${\bf{M}}$是一个$m \times n$矩阵，其中的元素全部属于实数域或复数域。那么存在一个分解使得： $${{\bf{M}}_{m \times n}} = {{\bf{U}}_{m \times m}}{{\bf{\Sigma }}_{m \times n}}{\bf{V}}_{n \times n}^*$$ 其中，${\bf{U}}$、${\bf{V}}$分别称为左、右奇异向量，$*$表示共轭转置，${\bf{\Sigma}}$对角线上的值是奇异值，其值按从大到小排列，且下降迅速。因此我们可以用前$r$个奇异值来近似描述原矩阵： $${{\bf{M}}_{m \times n}} \approx {{\bf{U}}_{m \times r}}{{\bf{\Sigma }}_{r \times r}}{\bf{V}}_{n \times r}^*$$ 其中，$r$是一个远小于$m$和$n$的数。 计算SVD computation example 评分预测 利用SVD将评分矩阵${\bf{R}}$分解为${\bf{U}}$、${\bf{\Sigma }}$、${\bf{V}}$； 将${\bf{\Sigma }}$简化为维数是$r$的矩阵，得到${{\bf{\Sigma }}_r}$； 相应地简化${\bf{U}}$、${\bf{V}}$得到矩阵${{\bf{U}}_r}$与${{\bf{V}}_r}$； 计算两个相关矩阵${{\bf{U}}_k} = {{\bf{U}}_r} \cdot \sqrt {{{\bf{\Sigma }}_r}} $与${{\bf{V}}_k} = \sqrt {{{\bf{\Sigma }}_r}} \cdot {\bf{V}}_r^T$； 计算用户$u$对未评分项目$i$的预测评分：${\hat r_{ui}} = {{\bf{U}}_k}\left( u \right) \cdot {{\bf{V}}_k}\left( i \right)$。 优点： 提取评分矩阵关键特征，简化数据，去除噪声和冗余数据 缺点： 需要将稀疏评分矩阵补全成稠密矩阵，而实践中评分矩阵往往非常庞大且稀疏，一旦补全成稠密的，将会占用非常大的空间 算法复杂度严重依赖SVD方法，在稠密大规模矩阵上分解时，速度非常慢 Funk-SVDNetflix Prize开始后，Simon Funk在其个人博客中公布了一个基于SVD的改进算法(Funk-SVD)，一下子引爆了推荐系统研究者对于矩阵分解的关注。这种改进算法称为隐语义模型或潜在因素模型。 LFMLatent Factor Model, 潜在因素模型 定义 将评分矩阵分解为用户隐含特征组成的矩阵和项目隐含特征组成的矩阵，类似于SVD算法中的${{\bf{U}}_r}$与${{\bf{V}}_r}$： $${\bf{R}} \approx {{\bf{P}}^T}{\bf{Q}}$$ ${\bf{P}}$为$k \times m$矩阵，表示用户特征向量；${\bf{Q}}$为$k \times n$矩阵，表示物品特征向量。那么$u$对$i$预测评分为： $${\hat r_{ui}} = {\bf{p}}_u^T{{\bf{q}}_i}$$ 求解 采用最小化误差函数的方法来求解，转化为最优化问题。 定义损失函数： $$C = \sum\limits_{(u,i) \in R} {{{\left( {{r_{u,i}} - {\bf{p}}_u^T{{\bf{q}}_i}} \right)}^2}} {\rm{ + }}\lambda \left( {{{\left\| {{{\bf{p}}_u}} \right\|}^2} + {{\left\| {{{\bf{q}}_i}} \right\|}^2}} \right)$$ 目标： $$\mathop {\min }\limits_{{{\bf{p}}_u},{{\bf{q}}_i}} C$$ 最优化算法两种常用的算法： 梯度下降法Simon Funk所采用的方法，为了减少计算量，采用随机梯度下降SDG(Stochastic Gradient Descent) 交替最小二乘法通常SGD比ALS(Alternating Least Squares)简单而且快速，但是ALS的并行性能比较好，而且可以较好地处理稀疏数据 ALS 目标： $$\mathop {\min }\limits_{{{\bf{p}}_u},{{\bf{q}}_i}} \sum\limits_{(u,i) \in R} {{{\left( {{r_{u,i}} - {\bf{p}}_u^T{{\bf{q}}_i}} \right)}^2}} {\rm{ + }}\lambda \left( {{{\left\| {{{\bf{p}}_u}} \right\|}^2} + {{\left\| {{{\bf{q}}_i}} \right\|}^2}} \right)$$ 因为变量${{{\bf{p}}_u}}$和${{{\bf{q}}_i}}$耦合到一起，不好求解，因此可以先固定${\bf{Q}}$，求解${\bf{P}}$；再固定${\bf{P}}$，求解${\bf{Q}}$，如此交替反复，直至收敛。 先固定${\bf{Q}}$，将损失函数$C$对${{{\bf{p}}_u}}$求偏导，并令导数等于0，得到： ${{\bf{p}}_u} = {\left( {{{\bf{Q}}^T}{\bf{Q}} + \lambda {\bf{E}}} \right)^{ - 1}}{{\bf{Q}}^T}{{\bf{r}}_u}$&nbsp;&nbsp;&nbsp;&nbsp;(1) 同理固定${\bf{P}}$，可得： ${{\bf{q}}_i} = {\left( {{{\bf{P}}^T}{\bf{P}} + \lambda {\bf{E}}} \right)^{ - 1}}{{\bf{P}}^T}{{\bf{r}}_i}$&nbsp;&nbsp;&nbsp;&nbsp;(2) 证明 具体步骤： 随机初始化${\bf{Q}}$，利用公式(1)更新得到${\bf{P}}$，然后利用公式(2)更新${\bf{Q}}$，直到误差值变化很小或者达到最大迭代次数。 实现Spark MLlib 主要方法训练ALS伴生对象是建立ALS模型的入口，主要方法： train(ratings, rank, iterations, lambda)：训练模型，返回MatrixFactorizationModel 传入参数： ratings：评分RDD格式(userID, productID, rating)对 rank：特征数量 iterations：迭代数量 lambda：正则因子 预测MatrixFactorizationModel是用来预测评分的模型，主要方法： predict(user: Int, product: Int)：返回user用户对product物品的预测评分 代码12345678910// 建立模型val rank = 10val numIterations = 20val model = ALS.train(trainRatings, rank, numIterations, 0.01)// 预测结果val predictions = model.predict(usersProducts).map &#123; case Rating(user, product, rate) =&gt; ((user, product), rate)&#125; 结果误差： MAE = 0.9112771540040457 RMSE = 1.2129820340745725 改进带有偏置的MF 不同的人打分的偏好不同，有的人愿意都给高分，有的人打分则比较保守。修改评分预测公式： $${\hat r_{ui}} = \mu + {b_u} + {b_i} + {\bf{p}}_u^T{{\bf{q}}_i}$$ 加入$\mu $全部评分的总体平均分，${b_u}$是用户$u$打分行为的偏差，${b_i}$是物品$i$收到打分的偏差，选取一种最优化算法训练出${b_u}$、${b_i}$、${{{\bf{p}}_u}}$和${{{\bf{q}}_i}}$。 带有隐反馈的MF(SVD++) 用户评分的物品只占很少一部分，但是用户的浏览、点击行为从一定程度上也反应了他对物品的兴趣，而这些都是隐性的反馈因素。因此，考虑修改评分预测公式： $${\hat r_{ui}} = \mu + {b_u} + {b_i} + \left( {{\bf{p}}_u^T{\rm{ + }}{1 \over {\sqrt {\left| {N\left( u \right)} \right|} }}\sum\limits_{j \in N\left( u \right)} {{{\bf{y}}_{\bf{j}}}} } \right){{\bf{q}}_i}$$ ${N\left( u \right)}$是用户$u$浏览或评论过的物品集合，${{\bf{y}}_j}$表示历史行为表现出来的偏好，和前面向量的维度相同。 非负矩阵分解(NMF) 在矩阵分解的过程中增添一些限制，如分解出来的矩阵${\bf{P}}$和${\bf{Q}}$的元素不允许出现负值。 其他 ALS-WR增加置信度权重来权衡显性和隐性反馈的比重。 考虑时间因素用户的兴趣度会随时间的推移而变化，因此将会随时间变化的因素表示为时间的函数。 带标签的MF加入用户的标签（比如年龄、性别、职业）来推测对每个因素的喜爱程度。 阅读参考： 几何角度解释SVD Simon Funk’s Blog Recommender Systems [Netflix] Non-negative matrix factorization 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/12/CF-MF/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Coursera - Scala 函数式程序设计原理 - 学习笔记 (1)]]></title>
      <url>%2F2016%2F12%2F07%2FCoursera-FP-in-Scala-Note-Part1%2F</url>
      <content type="text"><![CDATA[此笔记是在学习 Coursera 上 Functional Programming Principles in Scala 课程时所整理，方便今后查阅。 Getting StartedSBT 相关知识以及作业提交在 sbt 的术语中，基础目录或者是项目的根目录，指的是包含项目的目录。而 build.sbt 就是基础目录。src的目录结构：1234567891011121314151617src/ main/ resources/ &lt;files to include in main jar here&gt; scala/ &lt;main Scala sources&gt; java/ &lt;main Java sources&gt; test/ resources &lt;files to include in test jar here&gt; scala/ &lt;test Scala sources&gt; java/ &lt;test Java sources&gt;Other directories in src/ will be ignored. Additionally, all hiddendirectories will be ignored. project/ 文件夹下也可能有 .sbt文件，但是它们与基础目录的 sbt 文件作用不同。 在 sbt 文件所在处打开 CMD，键入sbt指令。sbt 指令只能在 sbt shell 中使用，不能在 Scala REPL 中使用。但是，可以在 sbt shell 中开启Scala解释器，输入console指令。当从sbt中启动解释器的时候，项目中的所有代码会被加载，并且可以直接访问。因此，Scala REPL 只能在项目没有错误的时候才能启动成功。ctrl + D退出。使用 compile 指令编译代码。src/test/scala 目录中包含的是测试代码，使用 test 指令进行测试。当项目中有一个 object 对象，并且含有 main 函数（或者是继承自 App），那么可以使用 run 指令运行程序。如果有多个 main 函数，那么会询问执行哪一个。 Scala Tutorial两种方式实现 HelloWorld：1234567891011// #1object HelloWorld extends App &#123; println("Hello, World!")&#125;// #2object HelloWorld &#123; def main(args: Array[String]) &#123; println("Hello, World!") &#125;&#125; 官方文档建议使用定义 main 函数的方法来实现，前者有可能出现各种问题。 Functions &amp; EvaluationProgramming Paradigms 编程范型函数式编程意味着避免变化 mutation。狭义上说，函数式编程FP意味着不使用变量 mutable variable、分配 assignment、循环 loop以及其他必要的控制结构 imperative control structure。广义上说，集中注意在程序中的函数上。函数在 FP 语言中是第一等公民： 可以在任何地方定义，包括其他函数的内部 可以被当做参数传入以及返回 Elements of Programming 编程元素交互式 shell，也被称作 RELP(Read-Eval-Print-Loop)，通过输入 scala 开启。Scala 参数与返回值类型： Int：32位整数 Double：64位浮点数 Boolean：布尔值 true 或者 false 计算步骤：12345678910111213141516// 表达式计算：(2 * pi) * radius(2 * 3.14159) * radius6.28318 * radius6.28318 * 1062.8318// 函数计算：sumOfSquares(3, 2+2)sumOfSquares(3, 4)square(3) + square(4)3 * 3 + square(4)9 + square(4)9 + 4 * 49 + 1625 替代模型 substitution model： 只要没有副作用，所有的表示式都可以用替代模型表示。C++ 这个表达式就具有副作用，因为每次计算后C的值都会改变，并不是所有的表达式最后都会计算出一个值（在有限的步骤内），例如：123def loop: Int = loop// 调用loop Call-by-name and Call-by-value：1234567891011121314151617181920// call-by-valuesumOfSquares(3, 2+2)sumOfSquares(3, 4)square(3) + square(4)3 * 3 + square(4)9 + square(4)9 + 4 * 49 + 1625// call-by-namesumOfSquares(3, 2+2)square(3) + square(2+2)3 * 3 + square(2+2)9 + square(2+2)9 + (2+2) * (2+2)9 + 4 * (2+2)9 + 4 * 49 + 1625 call-by-value：每个函数参数都只计算一次call-by-name：当对应该的参数在函数计算体内没有被时用到的话，就不会被计算1234567// which strategy is fastest?def test(x: Int, y: Int) = x * xtest(2,3) // sametest(3+4, 8) // CBVtest(7, 2*4) // CBNtest(3+4, 2*4) //same Evaluation Strategies and Termination 计算策略与终止如果表达式 e 的 CBV 计算终止了，那么 CBN 的计算也会终止；反过来则不一定是正确的。1234567def first(x: Int, y: Int) = x// CBNfirst(1, loop)// CBVfirst(1, loop) Scala 通常使用上的计算策略是 call-by-value ，但是如果一个参数类型以 =&gt;开头，那么它使用的策略是 call-by-name：12345def constOne(x: Int, y: =&gt; Int) = 1constOne(1+2, loop) // 1constOne(loop, 1+2) // loop Conditionals and Value Definitions 条件语句与值定义if-else在 Scala 中用作表达式，而不是声明：1def abs(x: Int) = if (x &gt;= 0) x else -x 值定义也没有 by-name 与 by-value，def用来定义 by-name,每一次时候都会重新进行计算；而 val 用来定义 by-value，val 的值只会计算一次：def 和 val 的区别在等式右边的表达式不会终止的时候很明显：12345def loop: Boolean = loopdef x = loop // OKval x = loop // lead to an infinite loop &amp;&amp; 和 || 可以写成：12345// anddef and(x:Boolean,y:=&gt;Boolean) = if(x) y else false// ordef or(x:Boolean,y:=&gt;Boolean) = if(x) true else y Example square roots with Newton’s method 使用牛顿方法实现平方根实现平方根算法：123456789101112131415161718def abs(x: Double) = if (x &lt; 0) -x else xdef sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x)def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) / x &lt; 0.001 // instead of abs(guess * guess - x) &lt; 0.001def improve(guess: Double, x: Double) = (guess + x / guess) / 2def sqrt(x: Double) = sqrtIter(1.0, x)sqrt(2)sqrt(4)sqrt(1e-6)sqrt(1e60) Blocks and Lexical Scope 块代码以及词法作用域将一个任务分解成若干个函数实现是很好的编程风格，但是 sqrtIter, improve, isGoodEnough 这个方法知识 sqrt 的实现，而不是使用。因此，我们可以将这个函数放到另外一个函数的内部，这样还可以有效避免命名空间污染 name-space pollution。12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x) def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) / x &lt; 0.001 def improve(guess: Double, x: Double) = (guess + x / guess) / 2 sqrtIter(1.0, x)&#125; Scala 中的 Block：block 定义在一堆花括号中{...}，内部包含了一系列的定义和表达式，block 的最后一个元素代表了它的值，block 自身是表达式，表达式可以出现在哪儿，block 就能出现在哪儿。block 内部的定义只有在 block 内部是可见的，外部不可见。而外部的定义只要没有在内部重新被定义，那么内部可以直接使用外部的定义。123456val x = 0def f(y: Int) = y + 1val result = &#123; val x = f(3) x * x&#125; + x // result = 16 除非定义在 block 内部被遮蔽 shadow 了，它都是可见的。因此，可以通过清除多余的变量来使程序变得简洁，sqrt 可以简化如下：12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double): Double = if (isGoodEnough(guess)) guess else sqrtIter(improve(guess)) def isGoodEnough(guess: Double) = abs(guess * guess - x) / x &lt; 0.001 def improve(guess: Double) = (guess + x / guess) / 2 sqrtIter(1.0)&#125; 如果一个表达式太长，通常会将表达式写成多行，但是：123456someLongExpression+ someOtherExpression// 相当于someLongExpression;+ someOtherExpression 通常会被当做是两个表达式，可以通过加小括号或者使+放在第一行来告诉 Scala，这个表达式还没有结束，如：12345(someLongExpression+ someOtherExpression)someLongExpression +someOtherExpression Tail Recursion 尾递归12345678910111213141516171819202122232425def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)// rewritegcd(14, 21)→ if (21 == 0) 14 else gcd(21, 14 % 21)→ if (false) 14 else gcd(21, 14 % 21)→ gcd(21, 14 % 21)→ gcd(21, 14)→ if (14 == 0) 21 else gcd(14, 21 % 14)→→ gcd(14, 7)→→ gcd(7, 0)→ if (0 == 0) 7 else gcd(0, 7 % 0)→ 7def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)// rewritefactorial(4)→ if (4 == 0) 1 else 4 * factorial(4 - 1)→→ 4 * factorial(3)→→ 4 * (3 * factorial(2))→→ 4 * (3 * (2 * factorial(1)))→→ 4 * (3 * (2 * (1 * factorial(0)))→→ 4 * (3 * (2 * (1 * 1)))→→ 120 两个函数的区别，前者不停地摆动，gcd(14,21) -&gt; gcd(21,14) -&gt; gcd(14,7) -&gt; gcd(7,0),但是总会重新变成对gcd的调用；后者中，每隔几步，我们都会增加一个新的元素到表达式中，表达式越来越长，直到简化到最后的结果。尾递归tail recursion一个函数在最后一步的时候调用它自己，而不能是自己去其他操作的混合操作，这样，这个函数的栈帧 stack frame 可以被重用，被称为尾递归。gcd 函数属于尾递归，而 factorial 函数不属于尾递归。尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。 function story() {从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。} 来源作者：酿泉链接：http://www.zhihu.com/question/20761771/answer/23254340 12345678910111213141516171819202122// 普通递归调用def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)// 尾递归调用def factorial2(n:Int, result:Int): Int = if (n == 0) result else factorial2(n-1, result * n)factorial(5) // 120factorial2(5,1) // 120// 普通递归调用function f(x) &#123; if (x === 1) return 1; return 1 + f(x-1);&#125;// 尾递归调用function f(x) &#123; if (x === 1) return 1; return f(x-1);&#125; Higher Order FunctionsHigher-Order Functions 高阶函数函数式编程语言把函数看成是 第一等值first-class value，也就是说，函数可以被当成参数传递给一个函数或者当成一个结果返回。而将函数当成参数传给另一个函数，或者将函数当做结果返回被称之为高阶函数。函数类型：使用A =&gt; B来表示函数类型，它表示，这个函数接受一个参数类型 A，并且返回结果是类型 B。123456789101112131415def sum(f: Int =&gt; Int, a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f, a+1, b)def sumInt(a: Int, b: Int) = sum(id, a, b)def sumCube(a: Int, b: Int) = sum(cube, a, b)def sumFact(a: Int, b: Int) = sum(fact, a, b)def id(x: Int): Int = xdef cube(x: Int): Int = x * x * xdef fact(x: Int): Int = if (x == 0) 1 else x * fact(x-1)sumInt(0,2)sumCube(0,2)sumFact(0,2) 但是，这样会有一个问题，我们创建了很多小的函数，如 id、cube、fact，这样会显得程序很臃肿，因此介绍函数字面量 function literal，又被称为匿名函数 anonymous function。例如：123456789// (x: Int)是函数的参数，x*x*x是函数体// 其中，参数的类型可以省略，因为编辑器可以根据上下文自动推断出类型(x: Int) =&gt; x * x * x// same asx =&gt; x * x * x// 接收多个参数的函数(x: Int, y: Int) =&gt; x + y// same as(x, y) =&gt; x + y 匿名函数是一种语法糖，可以让程序更加好写，(x1: T1, …, xn: Tn) =&gt; E 可以使用def来定义：{ def f(x1: T1, …, xn: Tn) = E; f }。 Currying 柯西里化函数返回值为函数：1234567891011121314151617181920212223// 接收参数是一个函数，返回值也是一个函数def sum(f: Int =&gt; Int) : (Int, Int) =&gt; Int = &#123; def sumF(a: Int, b: Int) : Int = if (a &gt; b) 0 else f(a) + sumF(a + 1, b) sumF&#125;// 上面代码可以改写// 这里就没有了重复的参数def sumInts = sum(x =&gt; x)def sumCubes = sum(x =&gt; x * x * x)def sumFactorials = sum(fact)def fact(x: Int): Int = &#123; if (x == 0) 1 else x * fact(x - 1)&#125;sumCubes(1, 10) + sumFactorials(10, 20) // 267634641// 可以直接跳过定义辅助函数sum(x =&gt; x)(1, 10) // 55 转化为多参数：123// 使用语法糖，进一步改写def sum(f: Int =&gt; Int)(a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f)(a + 1, b) 那么，上面 sum 函数的类型是什么？类型为 (Int =&gt; Int) =&gt; (Int, Int) =&gt; Int，函数类型为右结合，也就是说，Int =&gt; Int =&gt; Int 相当于 Int =&gt; (Int =&gt; Int)。12345678def mapReduce(f: Int =&gt; Int, combine: (Int, Int) =&gt; Int, zero: Int)(a: Int, b: Int): Int = &#123; if (a&gt;b) zero else combine(f(a), mapReduce(f, combine, zero)(a+1, b))&#125;def product(f: Int =&gt; Int)(a: Int, b: Int): Int = mapReduce(f, (x, y) =&gt; x * y, 1)(a, b)product(x =&gt; x)(1, 4) 当 mapReduce函数 与 product 函数中间出现其他函数定义的时候，可能会报错：multiple markers at this line- forward reference extends over definition of value res\$0- forward reference extends over definition of value res\$1 Example Finding Fixed Points 例子：找不动点不动点：x = f(x) 如果一个 x 的值满足前面的等式，那么可以看成是这个函数的不动点。因此，我们可以通过找不动点的方法来实现 sqrt。sqrt(x) 是方程 y =&gt; x / y 的不动点，但是这样计算不能够收敛于一点，于是我们通过与原值取平均的方法来使其收敛，并且可以将其抽取出一个函数：12345678910111213141516171819202122import scala.math._val tolerance = 0.0001def isCloseEnough(x: Double, y: Double) = abs((x - y) / x) / x &lt; tolerancedef fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = &#123; def iterate(guess: Double): Double = &#123; println(s"guess = $guess") val next = f(guess) if (isCloseEnough(guess, next)) next else iterate(next) &#125; iterate(firstGuess)&#125;//fixedPoint(x =&gt; 1 + x/2)(1)//fixedPoint(x =&gt; cos(x))(1)def averageDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2def sqrt(x: Double) = fixedPoint(averageDamp(y =&gt; x / y))(1.0)sqrt(2) Scala Syntax Summary 语法总结扩展的巴科斯范式 EBNF(Extended Backus-Naur form)123- | 表示可选- [...] 表示选择（0 或 1）- &#123;...&#125; 表示反复（0 或更多） Types 类型12345Type = SimpleType | FunctionTypeFunctionType = SimpleType &apos;=&gt;&apos; Type | &apos;(&apos; [Types] &apos;)&apos; &apos;=&gt;&apos; TypeSimpleType = IdentTypes = Type &#123;&apos;,&apos; Type&#125; A type can be: A numeric type: Int, Double (and Byte, Short, Char, Long, Float) The Boolean type with the value true and false The String type A function type, like Int =&gt; Int, (Int, Int) =&gt; Int Expressions 类型123456789101112Expr = InfixExpr | FunctionExpr | if &apos;(&apos; Expr &apos;)&apos; Expr else ExprInfixExpr = PrefixExpr | InfixExpr Operator InfixExprOperator = identPrefixExpr = [&apos;+&apos; | &apos;-&apos; | &apos;!&apos; | &apos;~&apos; ] SimpleExprSimpleExpr = ident | literal | SimpleExpr &apos;.&apos; ident | BlockFunctionExpr = Bindings &apos;=&gt;&apos; ExprBindings = ident [&apos;:&apos; SimpleType ] | &apos;(&apos; [ Binding &#123;&apos;,&apos; Binding &#125;] &apos;)&apos;Binding = ident [&apos;:&apos; Type ]Block = &apos;&#123;&apos; &#123; Def &apos;;&apos;&#125; Expr &apos;&#125;&apos; An expression can be: An identifier such as x, isGoodEnough A literal, like 0, 1.0, “abc” A function application, like sqrt(x) An operator application, like -x, y + x A selection, like math.abs A conditional expression, like if (x &lt; 0) -x else x A block, like { val x = math.abs(y) ; x * 2 } An anonymous function, like x =&gt; x + 1 Definitions123456Def = FunDef | ValDefFunDef = def ident &#123;‘(’ [ Parameters ] ‘)’&#125; [‘:’ Type ] ‘=’ ExprValDef = val ident [‘:’ Type ] ‘=’ ExprParameter = ident ‘:’ [ ‘=&gt;’ ] TypeParameters = Parameter &#123;‘,’ Parameter &#125; A definition can be: A function definition, like def square(x: Int) = x * x A value definition, like val y = square(2) A parameter can be: A call-by-value parameter, like (x: Int) A call-by-name parameter, like (y: =&gt; Double) Functions and Data 函数和数据类：1234class Rational(x: Int, y: Int) &#123; def numer = x def denom = y&#125; 这样的语句定义了两个实体： 一个新的类型，名字叫做 Rational 一个构造器Rational，用来创建这种类型的元素 对象：一个类型在程序中本质上是一系列的值，而属于一个类型的值称作对象，并且使用 new 操作符和类的构造器来创建一个对象。1new Rational(1, 2) 定义类中的函数称之为方法。 More Fun With Rationals 更多关于有理数的内容通过选择不同的数据实现方式，但是使用者不会察觉到的这种能力，我们称之为数据抽象 data abstraction。自我引用 self reference在一个类的内部，this 关键字代表了当前方法正在执行的那个对象上。1234567891011121314151617181920212223242526class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) def numer = x / g def denom = y / g def less(another: Rational) = this.numer * another.denom &lt; this.denom * another.numer def max(another: Rational) = if (this.less(another)) another else this def add(another: Rational) = new Rational( numer * another.denom + denom * another.numer, denom * another.denom) def neg = new Rational(-numer, denom) def sub(another: Rational) = add(another.neg) override def toString = numer + "/" + denom&#125; 可以使用 require 来限定构建一个新的对象必须满足的条件，如果不满足这样的条件，提示错误信息，我们称为 前提precondition。除了 require 之外，我们还有 assert 函数，assert 同样接收一个条件和一个可选的提示信息。但是不同的是，assert 抛出的是 AssertionError，而 require 抛出的是 IllegalArgumentException。这表明，它们使用的目的不同： require 被用来强制规定一个函数调用者的先决条件 assert 被用来检验函数自身的代码 在 Scala 中，类隐性地定义了一个构造器，称之为类的主构造器 primary constructor。主构造器取得类的所有参数，并且执行类体内的全部语句。像 Java 一样，我们可以设置不同的构造器，实现如下：12345678class Rational(x: Int, y: Int) &#123; ... def this(x: Int) = this(x, 1) ...&#125; this 用作函数名的时候表示这是类的另一个构造器，并且后面调用了类的主构造器。 Evaluation and Operators 求值与操作符求值evaluation类的定义如下：1234class C(x1, ..., xm) &#123; ... def f(y1, ..., yn) = b ... &#125;// 下面表达式的值如何计算？new C(v1, ..., vm).f(w1, ..., wn) / 代表，用左边的值替换表达式中右边的值。Example:123456789new Rational(1, 2).numer→ [1/x, 2/y][][new Rational(1, 2)/this] x= 1 // 1 for xnew Rational(1, 2).less(new Rational(2, 3))→ [1/x, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &lt; that.numer * this.denom= new Ration(1, 2).numer * new Rational(2, 3).denom &lt; new Ration(2, 3).numer * new Rational(1, 2).denom→→ 1 * 3 &lt; 2 * 2→→ true 操作符operator任何接收一个参数的方法都可以想一个插入的操作符一样使用，例如：123r add s r.add(s)r less s /* in place of */ r.less(s)r max s r.max(s) 在Scala中，操作符可以当做标识符，因此，标示符可以是： 数字、字母组合：以字母开头，后面跟着一系列的字母或者数字 符号：以一个操作符开头，后面跟着其他的操作符 下划线符号 ‘_’ 被当做一个字母 数字、字母组合的标识符同样可以下划线加操作符结尾 以下操作符都是合法的：x1*+?%&amp;vector++counter=由于在Scala中，前置的操作符，例如负数操作符 - 和中间的操作符，例如减号操作符 - 是不同的，因此需要进行特殊的转换，使用前缀 unary_ 加上操作符来表示。1234567891011121314151617181920class Rational(x: Int, y: Int) &#123; ... def &lt; (that: Rational) = this.numer * that.denom &lt; this.denom * that.numer def max(that: Rational) = if (this &lt; that) that else this def + (another: Rational) = new Rational( numer * another.denom + denom * another.numer, denom * another.denom) def unary_- : Rational = new Rational(-numer, denom) def - (another: Rational) = this + -another ...&#125; 需要注意的是， 如果一个方法以符号结尾，那么它与返回值: 之间必须要有空格隔开，否则会报错，因为冒号也是一个合法的符号，编译器会把冒号也看成是方法名的一部分。操作符的优先级：取决于它的第一个字符，如下表优先级依次变大：(all letters)|^&amp;&lt; &gt;= !:+ -* / %(all other special characters)1234567a + b ^? c ?^ d less a ==&gt; b | c=&gt;a + b ^? (c ?^ d) less a ==&gt; b | c(a + b) ^? (c ?^ d) less a ==&gt; b | c(a + b) ^? (c ?^ d) less (a ==&gt; b) | c((a + b) ^? (c ?^ d)) less (a ==&gt; b) | c((a + b) ^? (c ?^ d)) less ((a ==&gt; b) | c) Assignment自己编写 test 测试，内容的格式如下：123test("adding ints") &#123; assert(1 + 2 === 4)&#125; 测试名称叫做 add ints，asser t表示尝试进行 === 左边的操作，看是否与右边的结果相等，不相等则测试不通过，输出测试名称，以及测试没有通过的原因。如果使用 == 则只报错不输出原因。如果暂时不需要对写好的某个测试犯法执行，那么将 test 改成 ignore，就不会执行。我们可能需要给同样的测试对象实现不同的方法，一种办法是重复创建多次，更简便的方法是创建一个与测试分离的特征 trait 中，这样当我们创建 trait 实例的时候我们可以访问内部的所有变量。123456789trait TestSets &#123; val s1 = singletonSet(1) val s2 = singletonSet(2) val s3 = singletonSet(3)&#125;new TestSets &#123; assert(contains(s1, 2), "Singleton") // FunSets.contains($anon.this.s1, 2) was false Singleton&#125; 未完，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/07/Coursera-FP-in-Scala-Note-Part1/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo Blog 同步备份]]></title>
      <url>%2F2016%2F12%2F06%2FHexo-Backup%2F</url>
      <content type="text"><![CDATA[备份电脑A：1.在 Github 上新建一个仓库，例如 blog。2.上传电脑A本地Hexo博客的源文件到 Github 的 blog 仓库中：1) 删除根目录和主题目录下的 .git 文件夹2) 修改根目录下的 .gitignore 文件为： 12.deploy*/public/ 3) 依次执行以下指令，同步源文件至 Github： 123456$ git init$ git add .$ git commit -m "创建Hexo" # 更新信息$ git git remote add origin git@github.com:Username/Reponame$ git push -u origin master$ git pull -rebase origin master # 如果出现冲突先执行这条语句 即可将博客源文件上传到 Github。 同步电脑B：1.安装 Git。2.安装 Node.js。3.安装 Hexo： 1$ npm install -g hexo-cli 4.选择一个同步到本地的文件夹，执行 git clone： 1$ git clone git@github.com:Username/Reponame 到这里，两台电脑的 Hexo 环境一致，Hexo 博客源文件也一样。 两台电脑同步更新博客：1.先检查git pull，将本地博客源文件更新至最新版本： 1$ git pull 2.新建或修改博客内容，进行本机预览等操作： 12$ hexo new &lt;新的博客&gt;$ hexo server 3.同步 Hexo 源文件至 Github： 123$ git add .$ git commit -m "更新描述"$ git push origin master 4.最后生成 Hexo 静态博客文件并部署。 12$ hexo generate$ hexo deploy 本文参考原文，并重新整理，转载请注明出处：http://hijacking.cn/2016/12/06/Hexo-Backup/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0 - 读书笔记 (1)]]></title>
      <url>%2F2016%2F07%2F01%2FEffective-OC-Note-Part1%2F</url>
      <content type="text"><![CDATA[此笔记是在阅读《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》 时所整理，方便今后查阅。 熟悉OC了解OC语言的起源在类的头文件中尽量少引入其他头文件尽量晚地#import需要的头文件，使用@class进行『向前声明』（forward declaring）。如果两个类在各自头文件中引入对方的头文件，则会导致『循环引用』（chicken-and-egg situation）。虽然#import不会像#include导致死循环，但是两个类里有一个无法被正确编译。 最好将协议单独放在一个头文件中，如果把协议放在某个大的头文件里，那么只要引入此协议，就必定会引入那个头文件中的全部内容。然有些协议，例如委托协议（delegate protocol）就不用单独写一个头文件。 多用字面量语法，少用与之等价的方法字面量语法（literal syntax），一种语法糖（syntactic sugar） 1NSNumber *someNumber = [NSNumber numberWithInt:1]; 等价于： 1NSNumber *someNumber = @1; 还可以使用：字面量字符串 1NSString *someString = @“Effective Objective-C 2.0”; 字面量数值 1NSNumber *floatNumber = @2.5f; 字面量数组 12NSArray *animals = @[@“cat”, @“dog”, @“mouse”, @“badger”];NSString *dog = animals[1]; // 取下标操作，subscripting 使用字面量语法更加安全，因为一旦出现nil，便会抛出异常。字面量字典 12NSDictionary *personData = @&#123;@“firstName” : @“Matt”, @“lastName” : @“Galloway”, @“age” : @28&#125;;NSString *lastName = personData[@“lastName”]; 可变数组与字典 12mutableArray[1] = @“dog”;mutableDictionary[@“lastName”] = @“Galloway”; 局限使用字面量语法创造出来的对象都是不可变的，若想变成可变版本，需要复制一份： 1NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy]; 多使用类型常量，少用#define 预处理指令将 1#define ANIMATION_DERATION 0.3 替换为 1static const NSTimeInterval kAnimationDuration = 0.3; 此方法包含类型信息，清楚地描述了常量的含义。并且注意命名方式，若常量局限于某个编译单元（.m文件）之内，则在前面加字母k；若常量在类之外可见，则通常以类名为前缀。注意，变量一定要同时用static和const来声明。const用来保证变量不能被修改，而static意味着该变量仅在定义此变量的编译单元中可见。假如不加static，那么编译器会创建一个external symbol。 有时候需要对外公开某个常量。比如通知中心派发通知的时候，需要给通知一个名称。此类常量需放在『全局符号表』（global symbol table）中，以便可以在编译单元之外使用。 12345// In the header fileextern NSString *const EOCStringConstant;// In the implementation fileNSString *const EOCStringConstant = @"VALUE"; 在头文件中声明，在实现文件中定义。并且，命名时应该用与之相关的类名做前缀。如上例需要对可见的话 12345// EOCAnimatedView.hextern const NSTimeInterval EOCAnimatedViewAnimationDuration;// EOCAnimatedView.mconst NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3; 用枚举表示状态、选项、状态码123456enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef enum EOCConnectionState EOCConnectionState; 可以指定底层数据类型（underlying type）来保存枚举类型，可以向前声明枚举变量。 1enum EOCConnectionStateConnectionState : NSInteger &#123; /* ... */ &#125; Foundation框架中定义了一些辅助的宏，可以用这些宏来定义枚举值。 1234567891011typedef NS_ENUM(NSUUnteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123; EOCPermittedDirectionUP = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3,&#125;; 需要以按位或操作来组合枚举时使用NS_OPTIONS，不需要互相组合时，使用NS_ENUM定义。 对象、消息、运行期理解『属性』这一概念OC对象通常会把所需的数据保存为各种实例变量，实例变量一般通过『存取方法』（access method）来访问。如果使用属性，编译器会自动编写访问这些属性所需的方法（getter、setter），叫做『自动合成』（autosynthesis）。除此之外，还自动向类中添加适当类型的实例变量，并且在属性名前加下划线，作为实例变量的名字。如果使用@dynamic关键字，会告诉编译器，不要自动创建属性所用的实例变量，也不要为其创建存取方法。属性特质 原子性如果属性具备nonatomic特质，则不使用同步锁。 读/写权限 readwrite：拥有getter和setter readonly：仅拥有getter 内存管理语义 assign：设置方法只会执行针对『纯量类型』（scalar type，例如CGFloat或NSInteger等）的简单赋值操作。 strong：定义一种『拥有关系』（owning relationship）。设置方法会先保留新值，并释放旧值，然后再将新值设置上去。 weak：定义一种『非拥有关系』（nonowning relationship）。设置方法既不保留新值，也不释放旧值。在属性所指的对象销毁时，属性值也会清空（nil out）。 unsafe_unretained：语义与assign相同，但是适用于『对象类型』，表达一种『非拥有关系』，当目标对象销毁时，属性值不会自动清空（不安全，unsafe）。 copy：所属关系与strong类似。但设置方法并不保留新值，而是将其『拷贝』。 方法名可以通过getter\setter=&lt; name &gt;来设置获取方法或者设置方法的方法名。 在对象内部尽量直接访问实例变量在对象之外访问实例变量时，应该通过属性来做。在对象内部时，建议采用直接访问的形式读取，通过属性来设置。特殊情况： 在初始化方法中，应该直接访问实例变量。 在懒加载中，应该使用 『获取方法』来访问属性。 理解『对象等同性』这一概念某些对象提供了特殊的『等同性判定方法』（equality-checking method）。如isEqualToString，isEqual等。自己创建等同性判定方法： 12345678910111213141516171819- (BOOL)isEqualToPerson:（EOCPerson *）otherPerson &#123; if (self == object) return YES; if (![_firstName isEqualToString: otherPerson.firstName]) return NO; if (![_lastName isEqualToString: otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES;&#125;- (BOOL)isEqual:(id)object &#123; if ([self class] == [object class]) &#123; return [self isEqualToPerson:(EOCPerson *)object]; &#125; else &#123; return [super isEqual:object]; &#125;&#125; 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未被相同（isEqual 与 hash 方法）。 以『类族模式』隐藏实现细节『类族』（class cluster）是一种很有用的模式（pattern），可以隐藏『抽象基类』（abstract base class）背后的实现细节，对外提供一套简单的公共接口。 12- (BOOL)isKindOfClass: classObj // 判断是否是这个类或者这个类的子类的实例- (BOOL)isMemberOfClass: classObj // 判断是否是这个类的实例 在既有类中使用关联对象存放自定义数据从对象所属的类中继承一个子类，然后改用子类对象。然而，并非所有情况都可以那么做，有时候类的实例可能由某种机制所创建，而开发者无法令这种机制创建出自己所写的子类实例。这时候可以采用『关联对象』（Associated Object）。例如，想在一个类里同时处理多个警告信息视图，如果能在创建警告视图的时候直接把处理每个按钮的逻辑都写好，那么代码就简洁而清晰多了。 12345678910111213141516171819#import &lt;objc/runtime.h&gt;static void *EOCMyAlertViewKey = @"EOCMyAlertViewKey";- (void)askUserQuestion &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Question" message:@"what do you want to do" delegate:self cancelButtonTitle:@"取消" otherButtonTitles:@"继续", nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex) &#123; if (buttonIndex == 0) &#123; [self doCancel]; &#125; else &#123; [self doContinue]; &#125; &#125;; objc_setAssociatedObject(alter, EOCMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);[alter show];&#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey); block(buttonIndex);&#125; 但是，采用该方法的时候块可能要捕捉某些变量，会造成『保留环』（retain cycle）。这种做法只有在其他办法行不通的时候才考虑使用。取代方法是从中继承子类，把块保存为子类中的属性。 理解objc_msgSend的作用对象上调用方法在OC中叫做『传递消息』（pass a message）。消息有 名称 和 选择子（selector）。 1234// OC中给对象发送消息id returnValue = [someObject messageName: parameter];// 转化为一条标准的C语言函数调用id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); 消息由接受者、选择子及参数构成。给某对象『发送消息』（invoke a message）也就相当于在该对象上『调用方法』（call a method）。发送给某对象的全部消息都要由『动态消息派发系统』（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 理解消息转发机制当对象接收到无法解读的消息后，就会启动『消息转发』（message forwarding）机制，由此过程告诉对象应该如何处理未知消息。 12// 控制台如下信息说明 曾向某个对象发送了一条其无法解读的消息，从而启动了消息转发机制，并将此消息发给了NSObject的默认实现unrecognized selector sent to instance 0x87... 开发者在编写自己的类时，可于转发过程中设置挂钩，用以执行预定的逻辑，而不使应用程序崩溃。 消息转发分为两大阶段，第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个『未知的选择子』（unknown selector），叫做『动态方法解析』（dynamic method resolution）。 第二阶段设计『完整的消息转发机制』（full forwarding mechanism）。首先，接收者看看有没有其他对象能处理这条消息，若有，则运行期系统会把消息转给那个对象，消息转发过程结束。若没有『备援的接收者』（replacement receiver），则启动完整的消息转发机制，runtime会把与消息有关的全部细节封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 12345678910// 动态方法解析// 对象收到无法解读的消息后，首先将调用其所属类的下列类方法+ (BOOL)resolveInstanceMethod:(SEL)selector;// 备援接收者// runtime问接收者，能不能把这条消息转发给其他接收者来处理- (id)forwardingTargetForSelector:(SEL)selector;// 完整的消息转发- (void)forwardInvocation:(NSInvocation *)invocation; 用『方法调配技术』测试『黑盒方法』方法调配（method swizzling）：与给定选择子名称对应的方法可以在运行期改变。既不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能。新功能将在本类的所有实例中生效。 1234// 交换方法实现void method_exchangeImplementations(Method m1, Method m2)// 获取方法实现Method class_getInstanceMethod(Class aClass, SEL aSelector) 通过此方案，可以为那些『完全不知道其具体实现的』（complete opaque）黑盒方法增加日志记录功能。 理解『类对象』的用意12345678910111213141516171819// id类型定义typedef struct objc_object &#123; Class isa;&#125; *id;// Class类型定义typedef struct objc_class *Class;struct objc_Class &#123; Class *isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols;&#125; 在类继承体系中查询类型信息：isMemberOfClass判断对象是否为某个特定类的实例，isKindOfClass判断对象是否为某类或其派生类的实例。每个实例都有一个指向Class对象的指针，用以表明其类型。 接口与API设计用前缀避免命名空间冲突OC没有其他语言内置的『命名空间』（namespace）机制。选择与公司或应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。若自己所开发的程序库中使用到了第三方库，则应为其中的名称加上前缀。 提供『全能初始化方法』把这种可为对象提供必要信息以便其能完成工作的初始化方法叫做『全能/指定初始化方法』（designated initializer）。 12345678910111213141516171819202122// Rectangle.m- (id)initWithWidth:(float)width andHeight:(float)height &#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// 如果有人调用[[Rectangle alloc]init]来创建，所有的实例变量都会设为0（或是与0等价的值）// 不过我们一般希望自己能设置默认的宽度和高度，或者抛出异常// 使用下面任意一种方法来覆写init方法// Using default values- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Throwing an exception- (id)init &#123; @throw [NSException exceptionWithName:NSInternalInconsistentcyException reason:@"Must use initWithWidth:andHeight: instead." useInfo:nil];&#125; 全能初始化方法的调用链一定要维系。并且，如果子类的全能初始化方法与超类方法的名称不同，那么总应覆写超类的全能初始化方法（调用本类的全能初始化方法）。如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。有时候，可能需要编写多个全能初始化方法，因为对象的实例可能有两种完全不同的创建方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Rectangle.m// Designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// Superclass's designated initializer- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Initializer from NSCoding- (id)initWithCoder:(NSCoder *)decoder &#123; // call through to super's designated initializer if ((self = [super init])) &#123; _width = [decoder decodeFloatForKey:@"width"]; _height = [decoder decodeFloatForKey:@"height"]; &#125; return self;&#125;// Square.m// Designated initializer- (id)initWithDimension:(float)dimension &#123; return [super initWidth:dimension andHeight:dimension];&#125;// Superclass's designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; float dimension = MAX(width, height); return [self initWithDimension:dimension];&#125;// NSCoding designated initializer- (id)initWithCoder:(NSCoder *)decoder &#123; if ((self = [super initWithCoder:decoder])) &#123; // Square's specific initializer &#125;&#125; 每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。 实现descripiton方法自定义类时可以覆写description方法并将描述此对象的字符串返回。 1234// Person.m- (NSString *)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, \"%@ %@\"&gt;", [self class], self, _firstName, _lastName];&#125; 有个简单的方法，可以借助NSDictionary类的description方法，可以在description中输出很多互不相同的信息。 123- (NSString *)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@&gt;", [self class], self, @&#123;@"title":_title, @"latitude":@(_latitude), @"longitude":@(_longitude)&#125;];&#125; debugDescription是开发者在调试器（debugger）中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，此方法直接调用description。实现description方法返回一个有意义的字符串，用以描述该实例。但若想在调试时打印出更详尽的对象描述信息，则应该实现debugDescription方法。 尽量使用不可变对象设计类的时候，应该充分运用属性来封装数据。而在使用属性时，可将其声明为『只读』（read-only）。但是设置为read-only的属性在对象外部仍然可以通过『键值编码』（Key-Value Coding, KVC）技术setValue:forKey:设置这些属性值。不过这么做等于违规地绕过了本类所提供的API，使用这种『杂技代码』（hack）的话，得自己来应对可能出现的问题。尽量创建不可变的对象。若某属性仅可用于对象内部修改，则在『class-continuation分类』中将其由readonly属性扩展为readwrite属性。不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。 使用清晰而协调的命名方式方法命名： 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语 应该把表示参数类型的名词放在参数前面 如果方法要在当前对象上执行操作，那么就应该包括动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词 将get这个前缀留给那些借由『输出参数』来保存返回值的方法，比如getCharacters:range，调用此方法时，要在首个参数中传入数组，该方法所获取的字符正是要放到这个数组里面。 为私有方法名添加前缀可以使用p_或者类名前缀作为前缀。 理解Objective-C错误模型OC中的异常只用于处理致命错误（fatal error），在非致命错误（nonfatal error）时，OC所用的编程范式为：令方法返回nil/0，或者是使用NSError，以表明其中有错误发生。NSError对象里封装了三条信息： Error domain（错误范围，类型为字符串）：发生错误的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。 Error code（错误码，类型为整数）：独特的错误代码，指明在某个范围内具体发生了何种错误。 User info（用户信息，类型为字典）：有关此错误的额外信息，其中或许包含一段『本地化的描述』，或许还有含有导致该错误发生的另外一个错误。NSError经由方法的『输出参数』返回给调用者。 1- (BOOL)doSomething:(NSError **)error 这样，此方法不仅能有普通的返回值，而且还能经由『输出参数』把NSError对象回传给调用者。 12345NSError *error = nil;BOOL ret = [object doSomething:&amp;error];if (error) &#123; // There was an error&#125; 像这样的方法一般都会返回Boolean值，用来表示成功了还是失败了。如果不关注具体的错误信息，那么直接判断这个Boolean值就好。 1234BOOL ret = [object doSomething:nil];if (ret) &#123; // There was an error&#125; 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。在错误不那么严重的情况下，可以指派『委托方法』（delegate method）来处理错误，也可以把错误信息放在NSError对象里，经由『输出参数』返回给调用者。 理解NSCopying协议OC中，使用copy方法来进行拷贝。如果想令自己的类支持拷贝操作，那么就要实现NSCopying协议，该协议只有一个方法： 1- (id)copyWithZone:(NSZone *)zone 以前开发程序时，需要把内存分成不同的区（zone），而对象会创建在某个区里。而现在每个程序只有一个区：『默认区』（default zone）。因此不必担心zone参数。NSMutableCopying协议定义了： 1- (id)mutableCopyWithZone:(NSZone *)zone 无论当前实例是否可变，若需获取其可变版本的拷贝，均应调用mutableCopy方法。同理，若需要不可变的拷贝，则总应通过copy方法来获取。深拷贝（deep copy）：在拷贝对象自身时，将其底层数据也一并复制过去。浅拷贝（shallow copy）：只拷贝容器对象本身，而不复制其中数据。一般情况下会使用浅拷贝。如果所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 12345- (id)deepCopy &#123; Person *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;&#125; 未完，不定期更新，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/07/01/Effective-OC-Note-Part1/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS 去除优酷视频广告]]></title>
      <url>%2F2016%2F06%2F27%2FMacOS-Block-Youku-Ad%2F</url>
      <content type="text"><![CDATA[教程最早发表于威锋网，原帖地址。未经允许，不得转载。 修改hosts文件1.打开 Finder，同时按住 Shift + Command + G ，输入 /private/etc/ ，然后前往，找到 hosts 文件。 2.将 hosts 文件拷贝一份到桌面上，然后使用文本编辑器添加如下字段： 123456789101112131415127.0.0.1 atm.youku.com127.0.0.1 fvid.atm.youku.com127.0.0.1 html.atm.youku.com127.0.0.1 valb.atm.youku.com127.0.0.1 valf.atm.youku.com127.0.0.1 valo.atm.youku.com127.0.0.1 valp.atm.youku.com127.0.0.1 lstat.youku.com127.0.0.1 speed.lstat.youku.com127.0.0.1 urchin.lstat.youku.com127.0.0.1 stat.youku.com127.0.0.1 static.lstat.youku.com127.0.0.1 valc.atm.youku.com127.0.0.1 vid.atm.youku.com127.0.0.1 walp.atm.youku.com 3.保存并退出，将修改好的 hosts 文件替换原来的 hosts 文件，有密码会提示输入密码。 删除优酷缓存文件夹打开 Finder，同时按住 Shift + Command + G ，输入 ~/Library/Preferences/Macromedia/Flash Player/#SharedObjects/ ，看到一个字母数字组成的文件夹，例如 479H5MNT（名字随机生成），将文件夹内的 static.youku.com 文件夹删除。 网页设置随便打开一个优酷视频网页，此时应该没有广告了，点击右下角的设置按钮，优先画质选择超清或高清，确定。 设置文件权限再次进入 ~/Library/Preferences/Macromedia/Flash Player/#SharedObjects/ 位置，一直进入里面的文件夹，找到 YOUKU_FSO_PROXY.sol 文件。右键点击选择“显示简介”，在最后共享与权限中将所有账户权限改成只读（不能修改点击右下角的锁解锁），最后点击通用中的已锁定。 对于极少部分人，如果按照上面步骤出现优酷黑屏，提示广告被屏蔽的话，试着将第二步中那个数字和字母随即生成的文件夹，如 479H5MNT ，整个删除，再按照上面的方法试一遍。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/06/27/MacOS-Block-Youku-Ad/，其他请联系Jiawei LU]]></content>
    </entry>

    
  
  
</search>
