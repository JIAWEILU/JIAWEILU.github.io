<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[协同过滤推荐之 矩阵分解模型]]></title>
      <url>%2F2016%2F12%2F12%2FCF-MF%2F</url>
      <content type="text"><![CDATA[推荐 SVDSingular Value Decomposition, 奇异值分解 定义 假设${\bf{M}}$是一个$m \times n$阶矩阵，其中的元素全部属于实数域或复数域。那么存在一个分解使得： $${{\bf{M}}_{m \times n}} = {{\bf{U}}_{m \times m}}{{\bf{\Sigma }}_{m \times n}}{\bf{V}}_{n \times n}^*$$ 其中，${\bf{U}}$、${\bf{V}}$分别称为左、右奇异向量，$*$表示共轭转置，${\bf{\Sigma}}$对角线上的值是奇异值，其值按从大到小排列，且下降迅速。因此我们可以用前$r$个奇异值来近似描述原矩阵： $${{\bf{M}}_{m \times n}} \approx {{\bf{U}}_{m \times r}}{{\bf{\Sigma }}_{r \times r}}{\bf{V}}_{n \times r}^*$$ 其中，$r$是一个远小于$m$和$n$的数。 计算SVD computation example 评分预测 利用SVD将评分矩阵${\bf{R}}$分解为${\bf{U}}$、${\bf{\Sigma }}$、${\bf{V}}$； 将${\bf{\Sigma }}$简化为维数是$r$的矩阵，得到${{\bf{\Sigma }}_r}$； 相应地简化${\bf{U}}$、${\bf{V}}$得到矩阵${{\bf{U}}_r}$与${{\bf{V}}_r}$； 计算两个相关矩阵${{\bf{U}}_k} = {{\bf{U}}_r} \cdot \sqrt {{{\bf{\Sigma }}_r}} $与${{\bf{V}}_k} = \sqrt {{{\bf{\Sigma }}_r}} \cdot {\bf{V}}_r^T$； 计算用户$u$对未评分项目$i$的预测评分：${\hat r_{ui}} = {{\bf{U}}_r}\left( u \right) \cdot {{\bf{V}}_r}\left( i \right)$。 优点： 提取评分矩阵关键特征，简化数据，去除噪声和冗余数据 缺点： 需要将稀疏评分矩阵补全成稠密矩阵，而实践中评分矩阵往往非常庞大且稀疏，一旦补全成稠密的，将会占用非常大的空间 算法复杂度严重依赖SVD方法，在稠密大规模矩阵上分解时，速度非常慢 Funk-SVDNetflix Prize开始后，Simon Funk在其个人博客中公布了一个基于SVD的改进算法(Funk-SVD)，一下子引爆了推荐系统研究者对于矩阵分解的关注。这种改进算法称为隐语义模型或潜在因素模型。 LFMLatent Factor Model, 潜在因素模型 定义 将评分矩阵分解为用户隐含特征组成的矩阵和项目隐含特征组成的矩阵，类似于SVD算法中的${{\bf{U}}_r}$与${{\bf{V}}_r}$： $${\bf{R}} \approx {{\bf{P}}^T}{\bf{Q}}$$ ${\bf{P}}$为$k \times m$矩阵，表示用户特征向量；${\bf{Q}}$为$k \times n$矩阵，表示物品特征向量。那么$u$对$i$预测评分为： $${\hat r_{ui}} = {\bf{p}}_u^T{{\bf{q}}_i}$$ 求解 采用最小化误差函数的方法来求解，转化为最优化问题。 定义损失函数： $$C = \sum\limits_{(u,i) \in R} {\left[ {{{\left( {{r_{u,i}} - {\bf{p}}_u^T{{\bf{q}}_i}} \right)}^2} + \lambda \left( {{{\left\| {{{\bf{p}}_u}} \right\|}^2} + {{\left\| {{{\bf{q}}_i}} \right\|}^2}} \right)} \right]} $$ 目标： $$\mathop {\min }\limits_{{{\bf{p}}_u},{{\bf{q}}_i}} C$$ 最优化算法两种常用的算法： 梯度下降法Simon Funk所采用的方法，为了减少计算量，采用随机梯度下降SDG(Stochastic Gradient Descent) 交替最小二乘法通常SGD比ALS(Alternating Least Squares)简单而且快速，但是ALS的并行性能比较好，而且可以较好地处理稀疏数据 ALS 目标： $$\mathop {\min }\limits_{{{\bf{p}}_u},{{\bf{q}}_i}} \sum\limits_{(u,i) \in R} {\left[ {{{\left( {{r_{u,i}} - {\bf{p}}_u^T{{\bf{q}}_i}} \right)}^2} + \lambda \left( {{{\left\| {{{\bf{p}}_u}} \right\|}^2} + {{\left\| {{{\bf{q}}_i}} \right\|}^2}} \right)} \right]} $$ 因为变量${{{\bf{p}}_u}}$和${{{\bf{q}}_i}}$耦合到一起，不好求解，因此可以先固定${\bf{Q}}$，求解${\bf{P}}$；在固定${\bf{P}}$，求解${\bf{Q}}$，如此交替反复，直至收敛。 - 先固定${\bf{Q}}$，将损失函数$C$对${{{\bf{p}}_u}}$求偏导，并令导数等于0，得到： ${{\bf{p}}_u} = {\left( {{{\bf{Q}}^T}{\bf{Q}} + \lambda {\bf{E}}} \right)^{ - 1}}{{\bf{Q}}^T}{{\bf{r}}_u}$&nbsp;&nbsp;&nbsp;&nbsp;(1) - 同理固定${\bf{P}}$，可得： ${{\bf{q}}_i} = {\left( {{{\bf{P}}^T}{\bf{P}} + \lambda {\bf{E}}} \right)^{ - 1}}{{\bf{P}}^T}{{\bf{r}}_i}$&nbsp;&nbsp;&nbsp;&nbsp;(2) 证明 具体步骤： 随机初始化${\bf{Q}}$，利用公式(1)更新得到${\bf{P}}$，然后利用公式(2)更新${\bf{Q}}$，直到误差值变化很小或者达到最大迭代次数。 Spark 实现Spark MLlib 主要方法训练ALS伴生对象是建立ALS模型的入口，主要方法： train(ratings, rank, iterations, lambda)：训练模型，返回MatrixFactorizationModel 传入参数： ratings：评分RDD格式(userID, productID, rating)对 rank：特征数量 iterations：迭代数量 lambda：正则因子 预测MatrixFactorizationModel是用来预测评分的模型，主要方法： predict(user: Int, product: Int)：返回user用户对product物品的预测评分 代码12345678910// 建立模型val rank = 10val numIterations = 20val model = ALS.train(trainRatings, rank, numIterations, 0.01)// 预测结果val predictions = model.predict(usersProducts).map &#123; case Rating(user, product, rate) =&gt; ((user, product), rate)&#125; 结果误差： MAE = 0.9112771540040457 RMSE = 1.2129820340745725 改进带有偏置的MF 不同的人打分的偏好不同，有的人愿意都给高分，有的人打分则比较保守。修改评分预测公式： $${\hat r_{ui}} = \mu + {b_u} + {b_i} + {\bf{p}}_u^T{{\bf{q}}_i}$$ 加入$\mu $全部评分的总体平均分，${b_u}$是用户$u$打分行为的偏差，${b_i}$是物品$i$收到打分的偏差，选取一种最优化算法训练出${b_u}$、${b_i}$、${{{\bf{p}}_u}}$和${{{\bf{q}}_i}}$。 带有隐反馈的MF(SVD++) 用户评分的物品只占很少一部分，但是用户的浏览、点击行为从一定程度上也反应了他对物品的兴趣，而这些都是隐性的反馈因素。因此，考虑修改评分预测公式： $${\hat r_{ui}} = \mu + {b_u} + {b_i} + \left( {{\bf{p}}_u^T{\rm{ + }}{1 \over {\sqrt {\left| {N\left( u \right)} \right|} }}\sum\limits_{j \in N\left( u \right)} {{{\bf{y}}_{\bf{j}}}} } \right){{\bf{q}}_i}$$ ${N\left( u \right)}$是用户$u$浏览或评论过的物品集合，${{y_j}}$表示历史数据所变现出来的偏好的向量，和前面向量的维度相同。 非负矩阵分解(NMF) 在矩阵分解的过程中增添一些限制，如分解出来的矩阵${\bf{P}}$和${\bf{Q}}$的元素不允许出现负值。 其他 ALS-WR增加置信度权重来权衡显性和隐性反馈的比重。 考虑时间因素用户的兴趣度会随时间的推移而变化，因此将会随时间变化的因素表示为时间的函数。 带标签的MF加入用户的标签（比如年龄、性别、职业）来推测对每个因素的喜爱程度。 阅读参考： 几何角度解释SVD Simon Funk’s Blog Recommender Systems [Netflix] Non-negative matrix factorization © 本文为Giraffe.ME原创，转载请联系Jiawei LU，并注明出处来自：http://hijacking.cn/2016/12/12/CF-MF/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Coursera - Scala 函数式程序设计原理 - 学习笔记 (1)]]></title>
      <url>%2F2016%2F12%2F07%2FCoursera-FP-in-Scala-Note-Part1%2F</url>
      <content type="text"><![CDATA[此笔记是在学习 Coursera 上 Functional Programming Principles in Scala 课程时所整理，方便今后查阅。 Getting StartedSBT 相关知识以及作业提交在 sbt 的术语中，基础目录或者是项目的根目录，指的是包含项目的目录。而 build.sbt 就是基础目录。src的目录结构：1234567891011121314151617src/ main/ resources/ &lt;files to include in main jar here&gt; scala/ &lt;main Scala sources&gt; java/ &lt;main Java sources&gt; test/ resources &lt;files to include in test jar here&gt; scala/ &lt;test Scala sources&gt; java/ &lt;test Java sources&gt;Other directories in src/ will be ignored. Additionally, all hiddendirectories will be ignored. project/ 文件夹下也可能有 .sbt文件，但是它们与基础目录的 sbt 文件作用不同。 在 sbt 文件所在处打开 CMD，键入sbt指令。sbt 指令只能在 sbt shell 中使用，不能在 Scala REPL 中使用。但是，可以在 sbt shell 中开启Scala解释器，输入console指令。当从sbt中启动解释器的时候，项目中的所有代码会被加载，并且可以直接访问。因此，Scala REPL 只能在项目没有错误的时候才能启动成功。ctrl + D退出。使用 compile 指令编译代码。src/test/scala 目录中包含的是测试代码，使用 test 指令进行测试。当项目中有一个 object 对象，并且含有 main 函数（或者是继承自 App），那么可以使用 run 指令运行程序。如果有多个 main 函数，那么会询问执行哪一个。 Scala Tutorial两种方式实现 HelloWorld：1234567891011// #1object HelloWorld extends App &#123; println("Hello, World!")&#125;// #2object HelloWorld &#123; def main(args: Array[String]) &#123; println("Hello, World!") &#125;&#125; 官方文档建议使用定义 main 函数的方法来实现，前者有可能出现各种问题。 Functions &amp; EvaluationProgramming Paradigms 编程范型函数式编程意味着避免变化 mutation。狭义上说，函数式编程FP意味着不使用变量 mutable variable、分配 assignment、循环 loop以及其他必要的控制结构 imperative control structure。广义上说，集中注意在程序中的函数上。函数在 FP 语言中是第一等公民： 可以在任何地方定义，包括其他函数的内部 可以被当做参数传入以及返回 Elements of Programming 编程元素交互式 shell，也被称作 RELP(Read-Eval-Print-Loop)，通过输入 scala 开启。Scala 参数与返回值类型： Int：32位整数 Double：64位浮点数 Boolean：布尔值 true 或者 false 计算步骤：12345678910111213141516// 表达式计算：(2 * pi) * radius(2 * 3.14159) * radius6.28318 * radius6.28318 * 1062.8318// 函数计算：sumOfSquares(3, 2+2)sumOfSquares(3, 4)square(3) + square(4)3 * 3 + square(4)9 + square(4)9 + 4 * 49 + 1625 替代模型 substitution model： 只要没有副作用，所有的表示式都可以用替代模型表示。C++ 这个表达式就具有副作用，因为每次计算后C的值都会改变，并不是所有的表达式最后都会计算出一个值（在有限的步骤内），例如：123def loop: Int = loop// 调用loop Call-by-name and Call-by-value：1234567891011121314151617181920// call-by-valuesumOfSquares(3, 2+2)sumOfSquares(3, 4)square(3) + square(4)3 * 3 + square(4)9 + square(4)9 + 4 * 49 + 1625// call-by-namesumOfSquares(3, 2+2)square(3) + square(2+2)3 * 3 + square(2+2)9 + square(2+2)9 + (2+2) * (2+2)9 + 4 * (2+2)9 + 4 * 49 + 1625 call-by-value：每个函数参数都只计算一次call-by-name：当对应该的参数在函数计算体内没有被时用到的话，就不会被计算1234567// which strategy is fastest?def test(x: Int, y: Int) = x * xtest(2,3) // sametest(3+4, 8) // CBVtest(7, 2*4) // CBNtest(3+4, 2*4) //same Evaluation Strategies and Termination 计算策略与终止如果表达式 e 的 CBV 计算终止了，那么 CBN 的计算也会终止；反过来则不一定是正确的。1234567def first(x: Int, y: Int) = x// CBNfirst(1, loop)// CBVfirst(1, loop) Scala 通常使用上的计算策略是 call-by-value ，但是如果一个参数类型以 =&gt;开头，那么它使用的策略是 call-by-name：12345def constOne(x: Int, y: =&gt; Int) = 1constOne(1+2, loop) // 1constOne(loop, 1+2) // loop Conditionals and Value Definitions 条件语句与值定义if-else在 Scala 中用作表达式，而不是声明：1def abs(x: Int) = if (x &gt;= 0) x else -x 值定义也没有 by-name 与 by-value，def用来定义 by-name,每一次时候都会重新进行计算；而 val 用来定义 by-value，val 的值只会计算一次：def 和 val 的区别在等式右边的表达式不会终止的时候很明显：12345def loop: Boolean = loopdef x = loop // OKval x = loop // lead to an infinite loop &amp;&amp; 和 || 可以写成：12345// anddef and(x:Boolean,y:=&gt;Boolean) = if(x) y else false// ordef or(x:Boolean,y:=&gt;Boolean) = if(x) true else y Example square roots with Newton’s method 使用牛顿方法实现平方根实现平方根算法：123456789101112131415161718def abs(x: Double) = if (x &lt; 0) -x else xdef sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x)def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) / x &lt; 0.001 // instead of abs(guess * guess - x) &lt; 0.001def improve(guess: Double, x: Double) = (guess + x / guess) / 2def sqrt(x: Double) = sqrtIter(1.0, x)sqrt(2)sqrt(4)sqrt(1e-6)sqrt(1e60) Blocks and Lexical Scope 块代码以及词法作用域将一个任务分解成若干个函数实现是很好的编程风格，但是 sqrtIter, improve, isGoodEnough 这个方法知识 sqrt 的实现，而不是使用。因此，我们可以将这个函数放到另外一个函数的内部，这样还可以有效避免命名空间污染 name-space pollution。12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x) def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) / x &lt; 0.001 def improve(guess: Double, x: Double) = (guess + x / guess) / 2 sqrtIter(1.0, x)&#125; Scala 中的 Block：block 定义在一堆花括号中{...}，内部包含了一系列的定义和表达式，block 的最后一个元素代表了它的值，block 自身是表达式，表达式可以出现在哪儿，block 就能出现在哪儿。block 内部的定义只有在 block 内部是可见的，外部不可见。而外部的定义只要没有在内部重新被定义，那么内部可以直接使用外部的定义。123456val x = 0def f(y: Int) = y + 1val result = &#123; val x = f(3) x * x&#125; + x // result = 16 除非定义在 block 内部被遮蔽 shadow 了，它都是可见的。因此，可以通过清除多余的变量来使程序变得简洁，sqrt 可以简化如下：12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double): Double = if (isGoodEnough(guess)) guess else sqrtIter(improve(guess)) def isGoodEnough(guess: Double) = abs(guess * guess - x) / x &lt; 0.001 def improve(guess: Double) = (guess + x / guess) / 2 sqrtIter(1.0)&#125; 如果一个表达式太长，通常会将表达式写成多行，但是：123456someLongExpression+ someOtherExpression// 相当于someLongExpression;+ someOtherExpression 通常会被当做是两个表达式，可以通过加小括号或者使+放在第一行来告诉 Scala，这个表达式还没有结束，如：12345(someLongExpression+ someOtherExpression)someLongExpression +someOtherExpression Tail Recursion 尾递归12345678910111213141516171819202122232425def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)// rewritegcd(14, 21)→ if (21 == 0) 14 else gcd(21, 14 % 21)→ if (false) 14 else gcd(21, 14 % 21)→ gcd(21, 14 % 21)→ gcd(21, 14)→ if (14 == 0) 21 else gcd(14, 21 % 14)→→ gcd(14, 7)→→ gcd(7, 0)→ if (0 == 0) 7 else gcd(0, 7 % 0)→ 7def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)// rewritefactorial(4)→ if (4 == 0) 1 else 4 * factorial(4 - 1)→→ 4 * factorial(3)→→ 4 * (3 * factorial(2))→→ 4 * (3 * (2 * factorial(1)))→→ 4 * (3 * (2 * (1 * factorial(0)))→→ 4 * (3 * (2 * (1 * 1)))→→ 120 两个函数的区别，前者不停地摆动，gcd(14,21) -&gt; gcd(21,14) -&gt; gcd(14,7) -&gt; gcd(7,0),但是总会重新变成对gcd的调用；后者中，每隔几步，我们都会增加一个新的元素到表达式中，表达式越来越长，直到简化到最后的结果。尾递归tail recursion一个函数在最后一步的时候调用它自己，而不能是自己去其他操作的混合操作，这样，这个函数的栈帧 stack frame 可以被重用，被称为尾递归。gcd 函数属于尾递归，而 factorial 函数不属于尾递归。尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。 function story() {从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。} 来源作者：酿泉链接：http://www.zhihu.com/question/20761771/answer/23254340 12345678910111213141516171819202122// 普通递归调用def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)// 尾递归调用def factorial2(n:Int, result:Int): Int = if (n == 0) result else factorial2(n-1, result * n)factorial(5) // 120factorial2(5,1) // 120// 普通递归调用function f(x) &#123; if (x === 1) return 1; return 1 + f(x-1);&#125;// 尾递归调用function f(x) &#123; if (x === 1) return 1; return f(x-1);&#125; Higher Order FunctionsHigher-Order Functions 高阶函数函数式编程语言把函数看成是 第一等值first-class value，也就是说，函数可以被当成参数传递给一个函数或者当成一个结果返回。而将函数当成参数传给另一个函数，或者将函数当做结果返回被称之为高阶函数。函数类型：使用A =&gt; B来表示函数类型，它表示，这个函数接受一个参数类型 A，并且返回结果是类型 B。123456789101112131415def sum(f: Int =&gt; Int, a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f, a+1, b)def sumInt(a: Int, b: Int) = sum(id, a, b)def sumCube(a: Int, b: Int) = sum(cube, a, b)def sumFact(a: Int, b: Int) = sum(fact, a, b)def id(x: Int): Int = xdef cube(x: Int): Int = x * x * xdef fact(x: Int): Int = if (x == 0) 1 else x * fact(x-1)sumInt(0,2)sumCube(0,2)sumFact(0,2) 但是，这样会有一个问题，我们创建了很多小的函数，如 id、cube、fact，这样会显得程序很臃肿，因此介绍函数字面量 function literal，又被称为匿名函数 anonymous function。例如：123456789// (x: Int)是函数的参数，x*x*x是函数体// 其中，参数的类型可以省略，因为编辑器可以根据上下文自动推断出类型(x: Int) =&gt; x * x * x// same asx =&gt; x * x * x// 接收多个参数的函数(x: Int, y: Int) =&gt; x + y// same as(x, y) =&gt; x + y 匿名函数是一种语法糖，可以让程序更加好写，(x1: T1, …, xn: Tn) =&gt; E 可以使用def来定义：{ def f(x1: T1, …, xn: Tn) = E; f }。 Currying 柯西里化函数返回值为函数：1234567891011121314151617181920212223// 接收参数是一个函数，返回值也是一个函数def sum(f: Int =&gt; Int) : (Int, Int) =&gt; Int = &#123; def sumF(a: Int, b: Int) : Int = if (a &gt; b) 0 else f(a) + sumF(a + 1, b) sumF&#125;// 上面代码可以改写// 这里就没有了重复的参数def sumInts = sum(x =&gt; x)def sumCubes = sum(x =&gt; x * x * x)def sumFactorials = sum(fact)def fact(x: Int): Int = &#123; if (x == 0) 1 else x * fact(x - 1)&#125;sumCubes(1, 10) + sumFactorials(10, 20) // 267634641// 可以直接跳过定义辅助函数sum(x =&gt; x)(1, 10) // 55 转化为多参数：123// 使用语法糖，进一步改写def sum(f: Int =&gt; Int)(a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f)(a + 1, b) 那么，上面 sum 函数的类型是什么？类型为 (Int =&gt; Int) =&gt; (Int, Int) =&gt; Int，函数类型为右结合，也就是说，Int =&gt; Int =&gt; Int 相当于 Int =&gt; (Int =&gt; Int)。12345678def mapReduce(f: Int =&gt; Int, combine: (Int, Int) =&gt; Int, zero: Int)(a: Int, b: Int): Int = &#123; if (a&gt;b) zero else combine(f(a), mapReduce(f, combine, zero)(a+1, b))&#125;def product(f: Int =&gt; Int)(a: Int, b: Int): Int = mapReduce(f, (x, y) =&gt; x * y, 1)(a, b)product(x =&gt; x)(1, 4) 当 mapReduce函数 与 product 函数中间出现其他函数定义的时候，可能会报错：multiple markers at this line- forward reference extends over definition of value res\$0- forward reference extends over definition of value res\$1 Example Finding Fixed Points 例子：找不动点不动点：x = f(x) 如果一个 x 的值满足前面的等式，那么可以看成是这个函数的不动点。因此，我们可以通过找不动点的方法来实现 sqrt。sqrt(x) 是方程 y =&gt; x / y 的不动点，但是这样计算不能够收敛于一点，于是我们通过与原值取平均的方法来使其收敛，并且可以将其抽取出一个函数：12345678910111213141516171819202122import scala.math._val tolerance = 0.0001def isCloseEnough(x: Double, y: Double) = abs((x - y) / x) / x &lt; tolerancedef fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = &#123; def iterate(guess: Double): Double = &#123; println(s"guess = $guess") val next = f(guess) if (isCloseEnough(guess, next)) next else iterate(next) &#125; iterate(firstGuess)&#125;//fixedPoint(x =&gt; 1 + x/2)(1)//fixedPoint(x =&gt; cos(x))(1)def averageDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2def sqrt(x: Double) = fixedPoint(averageDamp(y =&gt; x / y))(1.0)sqrt(2) Scala Syntax Summary 语法总结扩展的巴科斯范式 EBNF(Extended Backus-Naur form)123- | 表示可选- [...] 表示选择（0 或 1）- &#123;...&#125; 表示反复（0 或更多） Types 类型12345Type = SimpleType | FunctionTypeFunctionType = SimpleType &apos;=&gt;&apos; Type | &apos;(&apos; [Types] &apos;)&apos; &apos;=&gt;&apos; TypeSimpleType = IdentTypes = Type &#123;&apos;,&apos; Type&#125; A type can be: A numeric type: Int, Double (and Byte, Short, Char, Long, Float) The Boolean type with the value true and false The String type A function type, like Int =&gt; Int, (Int, Int) =&gt; Int Expressions 类型123456789101112Expr = InfixExpr | FunctionExpr | if &apos;(&apos; Expr &apos;)&apos; Expr else ExprInfixExpr = PrefixExpr | InfixExpr Operator InfixExprOperator = identPrefixExpr = [&apos;+&apos; | &apos;-&apos; | &apos;!&apos; | &apos;~&apos; ] SimpleExprSimpleExpr = ident | literal | SimpleExpr &apos;.&apos; ident | BlockFunctionExpr = Bindings &apos;=&gt;&apos; ExprBindings = ident [&apos;:&apos; SimpleType ] | &apos;(&apos; [ Binding &#123;&apos;,&apos; Binding &#125;] &apos;)&apos;Binding = ident [&apos;:&apos; Type ]Block = &apos;&#123;&apos; &#123; Def &apos;;&apos;&#125; Expr &apos;&#125;&apos; An expression can be: An identifier such as x, isGoodEnough A literal, like 0, 1.0, “abc” A function application, like sqrt(x) An operator application, like -x, y + x A selection, like math.abs A conditional expression, like if (x &lt; 0) -x else x A block, like { val x = math.abs(y) ; x * 2 } An anonymous function, like x =&gt; x + 1 Definitions123456Def = FunDef | ValDefFunDef = def ident &#123;‘(’ [ Parameters ] ‘)’&#125; [‘:’ Type ] ‘=’ ExprValDef = val ident [‘:’ Type ] ‘=’ ExprParameter = ident ‘:’ [ ‘=&gt;’ ] TypeParameters = Parameter &#123;‘,’ Parameter &#125; A definition can be: A function definition, like def square(x: Int) = x * x A value definition, like val y = square(2) A parameter can be: A call-by-value parameter, like (x: Int) A call-by-name parameter, like (y: =&gt; Double) Functions and Data 函数和数据类：1234class Rational(x: Int, y: Int) &#123; def numer = x def denom = y&#125; 这样的语句定义了两个实体： 一个新的类型，名字叫做 Rational 一个构造器Rational，用来创建这种类型的元素 对象：一个类型在程序中本质上是一系列的值，而属于一个类型的值称作对象，并且使用 new 操作符和类的构造器来创建一个对象。1new Rational(1, 2) 定义类中的函数称之为方法。 More Fun With Rationals 更多关于有理数的内容通过选择不同的数据实现方式，但是使用者不会察觉到的这种能力，我们称之为数据抽象 data abstraction。自我引用 self reference在一个类的内部，this 关键字代表了当前方法正在执行的那个对象上。1234567891011121314151617181920212223242526class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) def numer = x / g def denom = y / g def less(another: Rational) = this.numer * another.denom &lt; this.denom * another.numer def max(another: Rational) = if (this.less(another)) another else this def add(another: Rational) = new Rational( numer * another.denom + denom * another.numer, denom * another.denom) def neg = new Rational(-numer, denom) def sub(another: Rational) = add(another.neg) override def toString = numer + "/" + denom&#125; 可以使用 require 来限定构建一个新的对象必须满足的条件，如果不满足这样的条件，提示错误信息，我们称为 前提precondition。除了 require 之外，我们还有 assert 函数，assert 同样接收一个条件和一个可选的提示信息。但是不同的是，assert 抛出的是 AssertionError，而 require 抛出的是 IllegalArgumentException。这表明，它们使用的目的不同： require 被用来强制规定一个函数调用者的先决条件 assert 被用来检验函数自身的代码 在 Scala 中，类隐性地定义了一个构造器，称之为类的主构造器 primary constructor。主构造器取得类的所有参数，并且执行类体内的全部语句。像 Java 一样，我们可以设置不同的构造器，实现如下：12345678class Rational(x: Int, y: Int) &#123; ... def this(x: Int) = this(x, 1) ...&#125; this 用作函数名的时候表示这是类的另一个构造器，并且后面调用了类的主构造器。 Evaluation and Operators 求值与操作符求值evaluation类的定义如下：1234class C(x1, ..., xm) &#123; ... def f(y1, ..., yn) = b ... &#125;// 下面表达式的值如何计算？new C(v1, ..., vm).f(w1, ..., wn) / 代表，用左边的值替换表达式中右边的值。Example:123456789new Rational(1, 2).numer→ [1/x, 2/y][][new Rational(1, 2)/this] x= 1 // 1 for xnew Rational(1, 2).less(new Rational(2, 3))→ [1/x, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &lt; that.numer * this.denom= new Ration(1, 2).numer * new Rational(2, 3).denom &lt; new Ration(2, 3).numer * new Rational(1, 2).denom→→ 1 * 3 &lt; 2 * 2→→ true 操作符operator任何接收一个参数的方法都可以想一个插入的操作符一样使用，例如：123r add s r.add(s)r less s /* in place of */ r.less(s)r max s r.max(s) 在Scala中，操作符可以当做标识符，因此，标示符可以是： 数字、字母组合：以字母开头，后面跟着一系列的字母或者数字 符号：以一个操作符开头，后面跟着其他的操作符 下划线符号 ‘_’ 被当做一个字母 数字、字母组合的标识符同样可以下划线加操作符结尾 以下操作符都是合法的：x1*+?%&amp;vector++counter=由于在Scala中，前置的操作符，例如负数操作符 - 和中间的操作符，例如减号操作符 - 是不同的，因此需要进行特殊的转换，使用前缀 unary_ 加上操作符来表示。1234567891011121314151617181920class Rational(x: Int, y: Int) &#123; ... def &lt; (that: Rational) = this.numer * that.denom &lt; this.denom * that.numer def max(that: Rational) = if (this &lt; that) that else this def + (another: Rational) = new Rational( numer * another.denom + denom * another.numer, denom * another.denom) def unary_- : Rational = new Rational(-numer, denom) def - (another: Rational) = this + -another ...&#125; 需要注意的是， 如果一个方法以符号结尾，那么它与返回值: 之间必须要有空格隔开，否则会报错，因为冒号也是一个合法的符号，编译器会把冒号也看成是方法名的一部分。操作符的优先级：取决于它的第一个字符，如下表优先级依次变大：(all letters)|^&amp;&lt; &gt;= !:+ -* / %(all other special characters)1234567a + b ^? c ?^ d less a ==&gt; b | c=&gt;a + b ^? (c ?^ d) less a ==&gt; b | c(a + b) ^? (c ?^ d) less a ==&gt; b | c(a + b) ^? (c ?^ d) less (a ==&gt; b) | c((a + b) ^? (c ?^ d)) less (a ==&gt; b) | c((a + b) ^? (c ?^ d)) less ((a ==&gt; b) | c) Assignment自己编写 test 测试，内容的格式如下：123test("adding ints") &#123; assert(1 + 2 === 4)&#125; 测试名称叫做 add ints，asser t表示尝试进行 === 左边的操作，看是否与右边的结果相等，不相等则测试不通过，输出测试名称，以及测试没有通过的原因。如果使用 == 则只报错不输出原因。如果暂时不需要对写好的某个测试犯法执行，那么将 test 改成 ignore，就不会执行。我们可能需要给同样的测试对象实现不同的方法，一种办法是重复创建多次，更简便的方法是创建一个与测试分离的特征 trait 中，这样当我们创建 trait 实例的时候我们可以访问内部的所有变量。123456789trait TestSets &#123; val s1 = singletonSet(1) val s2 = singletonSet(2) val s3 = singletonSet(3)&#125;new TestSets &#123; assert(contains(s1, 2), "Singleton") // FunSets.contains($anon.this.s1, 2) was false Singleton&#125; 未完，接下篇。 © 本文为Giraffe.ME原创，转载请联系Jiawei LU，并注明出处来自：http://hijacking.cn/2016/12/07/Coursera-FP-in-Scala-Note-Part1/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo Blog 同步备份]]></title>
      <url>%2F2016%2F12%2F06%2FHexo-Backup%2F</url>
      <content type="text"><![CDATA[备份电脑A：1.在 Github 上新建一个仓库，例如 blog。2.上传电脑A本地Hexo博客的源文件到 Github 的 blog 仓库中：1) 删除根目录和主题目录下的 .git 文件夹2) 修改根目录下的 .gitignore 文件为： 12.deploy*/public/ 3) 依次执行以下指令，同步源文件至 Github： 123456$ git init$ git add .$ git commit -m "创建Hexo" # 更新信息$ git git remote add origin git@github.com:Username/Reponame$ git push -u origin master$ git pull -rebase origin master # 如果出现冲突先执行这条语句 即可将博客源文件上传到 Github。 同步电脑B：1.安装 Git。2.安装 Node.js。3.安装 Hexo： 1$ npm install -g hexo-cli 4.选择一个同步到本地的文件夹，执行 git clone： 1$ git clone git@github.com:Username/Reponame 到这里，两台电脑的 Hexo 环境一致，Hexo 博客源文件也一样。 两台电脑同步更新博客：1.先检查git pull，将本地博客源文件更新至最新版本： 1$ git pull 2.新建或修改博客内容，进行本机预览等操作： 12$ hexo new &lt;新的博客&gt;$ hexo server 3.同步 Hexo 源文件至 Github： 123$ git add .$ git commit -m "更新描述"$ git push origin master 4.最后生成 Hexo 静态博客文件并部署。 12$ hexo generate$ hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS 去除优酷视频广告]]></title>
      <url>%2F2016%2F06%2F27%2FMacOS-Block-Youku-Ad%2F</url>
      <content type="text"><![CDATA[教程最早发表于威锋网，原帖地址。未经允许，不得转载。 修改hosts文件1.打开 Finder，同时按住 Shift + Command + G ，输入 /private/etc/ ，然后前往，找到 hosts 文件。 2.将 hosts 文件拷贝一份到桌面上，然后使用文本编辑器添加如下字段： 123456789101112131415127.0.0.1 atm.youku.com127.0.0.1 fvid.atm.youku.com127.0.0.1 html.atm.youku.com127.0.0.1 valb.atm.youku.com127.0.0.1 valf.atm.youku.com127.0.0.1 valo.atm.youku.com127.0.0.1 valp.atm.youku.com127.0.0.1 lstat.youku.com127.0.0.1 speed.lstat.youku.com127.0.0.1 urchin.lstat.youku.com127.0.0.1 stat.youku.com127.0.0.1 static.lstat.youku.com127.0.0.1 valc.atm.youku.com127.0.0.1 vid.atm.youku.com127.0.0.1 walp.atm.youku.com 3.保存并退出，将修改好的 hosts 文件替换原来的 hosts 文件，有密码会提示输入密码。 删除优酷缓存文件夹打开 Finder，同时按住 Shift + Command + G ，输入 ~/Library/Preferences/Macromedia/Flash Player/#SharedObjects/ ，看到一个字母数字组成的文件夹，例如 479H5MNT（名字随机生成），将文件夹内的 static.youku.com 文件夹删除。 网页设置随便打开一个优酷视频网页，此时应该没有广告了，点击右下角的设置按钮，优先画质选择超清或高清，确定。 设置文件权限再次进入 ~/Library/Preferences/Macromedia/Flash Player/#SharedObjects/ 位置，一直进入里面的文件夹，找到 YOUKU_FSO_PROXY.sol 文件。右键点击选择“显示简介”，在最后共享与权限中将所有账户权限改成只读（不能修改点击右下角的锁解锁），最后点击通用中的已锁定。 对于极少部分人，如果按照上面步骤出现优酷黑屏，提示广告被屏蔽的话，试着将第二步中那个数字和字母随即生成的文件夹，如 479H5MNT ，整个删除，再按照上面的方法试一遍。 © 本文为Giraffe.ME原创，转载请联系Jiawei LU，并注明出处来自：http://hijacking.cn/2016/06/27/MacOS-Block-Youku-Ad/]]></content>
    </entry>

    
  
  
</search>
