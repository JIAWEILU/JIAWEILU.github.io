<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HDFS 常用操作]]></title>
      <url>%2F2016%2F12%2F15%2FHDFS-Commands%2F</url>
      <content type="text"><![CDATA[0. 几种指令区别在操作HDFS上的文件的时候，Hadoop给我们提供了一下两种（三种，但有一种被废弃）指令，它们分别是： hadoop fs: 适用范围最广，操作通用文件系统，例如Local FS、HDFS、HFTP FS、S3 FS等。 hadoop dfs: 进行与HDFS相关的操作，但是该方法已经被废弃，使用hdfs dfs代替。 hdfs dfs: 进行HDFS的相关操作。 值得注意，如果hadoop fs指令后未指明是何种文件系统，那么默认是HDFS，也就是说hadoop fs -ls /相当于hadoop fs -ls hdfs:///。还有一点，/path路径和path并不指向同一个目录，后者其实是/user/username/path的简写形式。这一点与Linux本地文件系统类似。 几种指令操作类似，下面以hadoop fs为例，介绍常用的几种操作。 1. FS Shell调用FS Shell指令为：bin/hadoop fs &lt;args&gt;的形式，如果在系统的环境变量的路径中添加了$Hadoop_HOME/bin，那么可以直接使用hadoop fs &lt;args&gt;指令。 2. 常用操作2.1 创建文件夹hadoop fs -mkdir &lt;paths&gt;：在HDFS上创建指令路径的目录。12# 在HDFS上新建一个data目录hadoop fs -mkdir /data 2.2 上载文件hadoop fs -put &lt;localsrc&gt; ... &lt;dst&gt;：将一个或多个本地文件上载到HDFS目录中。12# 将本地的u1.base和u1.test文件写入到HDFS中的data目录hadoop fs -put /home/linux/Documents/u1.base home/linux/Documents/u1.test /data 2.3 下载文件hadoop fs -get &lt;src&gt; &lt;localdst&gt;：复制文件到本地文件系统。123# 将HDFS中u1.base和u1.test复制到本地hadoop fs -get /data/u1.base /home/linux/Documentshadoop fs -get /data/u1.test /home/linux/Documents 2.4 复制文件hadoop fs -cp URI [URI …] &lt;dest&gt;：将文件从源路径复制到目的路径。12# 将data目录下的u1.base和u1.test文件复制到/data/ml100k文件夹下hadoop fs -cp /data/u1.base /data/u1.test /data/ml100k 2.5 移动文件hadoop fs -mv URI [URI …] &lt;dest&gt;：将文件从源路径移动到目的路径。不允许不同文件系统间移动文件。12# 将data目录下的u1.base和u1.test文件移动到/data/ml100k文件夹下hadoop fs -mv /data/u1.base /data/u1.test /data/ml100k 2.6 查看目录内容hadoop fs -ls &lt;args&gt;： 如果是文件：返回文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID 如果是目录：返回目录名 &lt;dir&gt; 修改日期 修改时间 权限 用户ID 组ID 12# 查看data目录下的直接子文件hadoop fs -ls /data 2.7 查看内容hadoop fs -cat URI [URI …]：将路径指定文件的内容输出到stdout。12查看u1.test文件的内容hadoop fs -cat /data/u1.test 2.8 删除文件hadoop fs -rm [-R] URI [URI …]：删除指定文件。12# 将data目录下u1.base、u1.testhadoop fs -rm /data/u1.base /data/u1.test 若想要删除文件夹及其路径内所有文件，则使用下面指令：12删除/data/ml100k目录下所有文件hadoop fs -rm -R /data/ml100k 3. 读取对于不同的文件系统，有不同的scheme，读取本地文件系统时候，应该使用file:///localpath；而对于HDFS，应该使用hdfs:///hdfspath。HDFS所有节点都可以读取，但是本地文件系统只能够读取本地文件，如果程序需要读本地文件，应该在所有节点的相同目录下都有该文件的备份。 阅读参考： 关于三种指令的区别，参考stackoverflow。 更多指令，参考Hadoop文档ch或en(最新稳定版)。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/15/HDFS-Commands/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[协同过滤推荐之 矩阵分解模型]]></title>
      <url>%2F2016%2F12%2F12%2FCF-MF%2F</url>
      <content type="text"><![CDATA[1. 推荐 2. SVDSingular Value Decomposition, 奇异值分解 2.1 定义 假设${\bf{M}}$是一个$m \times n$矩阵，其中的元素全部属于实数域或复数域。那么存在一个分解使得： $${{\bf{M}}_{m \times n}} = {{\bf{U}}_{m \times m}}{{\bf{\Sigma }}_{m \times n}}{\bf{V}}_{n \times n}^*$$ 其中，${\bf{U}}$、${\bf{V}}$分别称为左、右奇异向量，$*$表示共轭转置，${\bf{\Sigma}}$对角线上的值是奇异值，其值按从大到小排列，且下降迅速。因此我们可以用前$r$个奇异值来近似描述原矩阵： $${{\bf{M}}_{m \times n}} \approx {{\bf{U}}_{m \times r}}{{\bf{\Sigma }}_{r \times r}}{\bf{V}}_{n \times r}^*$$ 其中，$r$是一个远小于$m$和$n$的数。 2.2 计算SVD computation example 2.3 评分预测 利用SVD将评分矩阵${\bf{R}}$分解为${\bf{U}}$、${\bf{\Sigma }}$、${\bf{V}}$； 将${\bf{\Sigma }}$简化为维数是$r$的矩阵，得到${{\bf{\Sigma }}_r}$； 相应地简化${\bf{U}}$、${\bf{V}}$得到矩阵${{\bf{U}}_r}$与${{\bf{V}}_r}$； 计算两个相关矩阵${{\bf{U}}_k} = {{\bf{U}}_r} \cdot \sqrt {{{\bf{\Sigma }}_r}} $与${{\bf{V}}_k} = \sqrt {{{\bf{\Sigma }}_r}} \cdot {\bf{V}}_r^T$； 计算用户$u$对未评分项目$i$的预测评分：${\hat r_{ui}} = {{\bf{U}}_k}\left( u \right) \cdot {{\bf{V}}_k}\left( i \right)$。 优点： 提取评分矩阵关键特征，简化数据，去除噪声和冗余数据 缺点： 需要将稀疏评分矩阵补全成稠密矩阵，而实践中评分矩阵往往非常庞大且稀疏，一旦补全成稠密的，将会占用非常大的空间 算法复杂度严重依赖SVD方法，在稠密大规模矩阵上分解时，速度非常慢 2.4 Funk-SVDNetflix Prize开始后，Simon Funk在其个人博客中公布了一个基于SVD的改进算法(Funk-SVD)，一下子引爆了推荐系统研究者对于矩阵分解的关注。这种改进算法称为隐语义模型或潜在因素模型。 3. LFMLatent Factor Model, 潜在因素模型 3.1 定义 将评分矩阵分解为用户隐含特征组成的矩阵和项目隐含特征组成的矩阵，类似于SVD算法中的${{\bf{U}}_r}$与${{\bf{V}}_r}$： $${\bf{R}} \approx {{\bf{P}}^T}{\bf{Q}}$$ ${\bf{P}}$为$k \times m$矩阵，表示用户特征向量；${\bf{Q}}$为$k \times n$矩阵，表示物品特征向量。那么$u$对$i$预测评分为： $${\hat r_{ui}} = {\bf{p}}_u^T{{\bf{q}}_i}$$ 3.2 求解 采用最小化误差函数的方法来求解，转化为最优化问题。 定义损失函数： $$C = \sum\limits_{(u,i) \in R} {{{\left( {{r_{u,i}} - {\bf{p}}_u^T{{\bf{q}}_i}} \right)}^2}} {\rm{ + }}\lambda \left( {{{\left\| {{{\bf{p}}_u}} \right\|}^2} + {{\left\| {{{\bf{q}}_i}} \right\|}^2}} \right)$$ 目标： $$\mathop {\min }\limits_{{{\bf{p}}_u},{{\bf{q}}_i}} C$$ 3.3 最优化算法两种常用的算法： 梯度下降法Simon Funk所采用的方法，为了减少计算量，采用随机梯度下降SDG(Stochastic Gradient Descent) 交替最小二乘法通常SGD比ALS(Alternating Least Squares)简单而且快速，但是ALS的并行性能比较好，而且可以较好地处理稀疏数据 3.4 ALS 目标： $$\mathop {\min }\limits_{{{\bf{p}}_u},{{\bf{q}}_i}} \sum\limits_{(u,i) \in R} {{{\left( {{r_{u,i}} - {\bf{p}}_u^T{{\bf{q}}_i}} \right)}^2}} {\rm{ + }}\lambda \left( {{{\left\| {{{\bf{p}}_u}} \right\|}^2} + {{\left\| {{{\bf{q}}_i}} \right\|}^2}} \right)$$ 因为变量${{{\bf{p}}_u}}$和${{{\bf{q}}_i}}$耦合到一起，不好求解，因此可以先固定${\bf{Q}}$，求解${\bf{P}}$；再固定${\bf{P}}$，求解${\bf{Q}}$，如此交替反复，直至收敛。 先固定${\bf{Q}}$，将损失函数$C$对${{{\bf{p}}_u}}$求偏导，并令导数等于0，得到： ${{\bf{p}}_u} = {\left( {{{\bf{Q}}^T}{\bf{Q}} + \lambda {\bf{E}}} \right)^{ - 1}}{{\bf{Q}}^T}{{\bf{r}}_u}$&nbsp;&nbsp;&nbsp;&nbsp;(1) 同理固定${\bf{P}}$，可得： ${{\bf{q}}_i} = {\left( {{{\bf{P}}^T}{\bf{P}} + \lambda {\bf{E}}} \right)^{ - 1}}{{\bf{P}}^T}{{\bf{r}}_i}$&nbsp;&nbsp;&nbsp;&nbsp;(2) 证明 具体步骤： 随机初始化${\bf{Q}}$，利用公式(1)更新得到${\bf{P}}$，然后利用公式(2)更新${\bf{Q}}$，直到误差值变化很小或者达到最大迭代次数。 4. Spark 实现Spark MLlib 4.1 主要方法4.1.1 训练ALS伴生对象是建立ALS模型的入口，主要方法： train(ratings, rank, iterations, lambda)：训练模型，返回MatrixFactorizationModel 传入参数： ratings：评分RDD格式(userID, productID, rating)对 rank：特征数量 iterations：迭代数量 lambda：正则因子 4.1.2 预测MatrixFactorizationModel是用来预测评分的模型，主要方法： predict(user: Int, product: Int)：返回user用户对product物品的预测评分 4.2 代码12345678910// 建立模型val rank = 10val numIterations = 20val model = ALS.train(trainRatings, rank, numIterations, 0.01)// 预测结果val predictions = model.predict(usersProducts).map &#123; case Rating(user, product, rate) =&gt; ((user, product), rate)&#125; 4.3 结果误差： MAE = 0.9112771540040457 RMSE = 1.2129820340745725 5. 改进5.1 带有偏置的MF 不同的人打分的偏好不同，有的人愿意都给高分，有的人打分则比较保守。修改评分预测公式： $${\hat r_{ui}} = \mu + {b_u} + {b_i} + {\bf{p}}_u^T{{\bf{q}}_i}$$ 加入$\mu $全部评分的总体平均分，${b_u}$是用户$u$打分行为的偏差，${b_i}$是物品$i$收到打分的偏差，选取一种最优化算法训练出${b_u}$、${b_i}$、${{{\bf{p}}_u}}$和${{{\bf{q}}_i}}$。 5.2 带有隐反馈的MF(SVD++) 用户评分的物品只占很少一部分，但是用户的浏览、点击行为从一定程度上也反应了他对物品的兴趣，而这些都是隐性的反馈因素。因此，考虑修改评分预测公式： $${\hat r_{ui}} = \mu + {b_u} + {b_i} + \left( {{\bf{p}}_u^T{\rm{ + }}{1 \over {\sqrt {\left| {N\left( u \right)} \right|} }}\sum\limits_{j \in N\left( u \right)} {{{\bf{y}}_{\bf{j}}}} } \right){{\bf{q}}_i}$$ ${N\left( u \right)}$是用户$u$浏览或评论过的物品集合，${{\bf{y}}_j}$表示历史行为表现出来的偏好，和前面向量的维度相同。 5.3 非负矩阵分解(NMF) 在矩阵分解的过程中增添一些限制，如分解出来的矩阵${\bf{P}}$和${\bf{Q}}$的元素不允许出现负值。 5.4 其他 ALS-WR增加置信度权重来权衡显性和隐性反馈的比重。 考虑时间因素用户的兴趣度会随时间的推移而变化，因此将会随时间变化的因素表示为时间的函数。 带标签的MF加入用户的标签（比如年龄、性别、职业）来推测对每个因素的喜爱程度。 阅读参考： 几何角度解释SVD Simon Funk’s Blog Recommender Systems [Netflix] Non-negative matrix factorization 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/12/CF-MF/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Coursera - Scala 函数式程序设计原理 - 学习笔记 (1)]]></title>
      <url>%2F2016%2F12%2F07%2FCoursera-FP-in-Scala-Note-Part1%2F</url>
      <content type="text"><![CDATA[此笔记是在学习 Coursera 上 Functional Programming Principles in Scala 课程时所整理，方便今后查阅。 1. Getting Started1.1 SBT 相关知识以及作业提交在 sbt 的术语中，基础目录或者是项目的根目录，指的是包含项目的目录。而 build.sbt 就是基础目录。src的目录结构：1234567891011121314151617src/ main/ resources/ &lt;files to include in main jar here&gt; scala/ &lt;main Scala sources&gt; java/ &lt;main Java sources&gt; test/ resources &lt;files to include in test jar here&gt; scala/ &lt;test Scala sources&gt; java/ &lt;test Java sources&gt;Other directories in src/ will be ignored. Additionally, all hiddendirectories will be ignored. project/ 文件夹下也可能有 .sbt文件，但是它们与基础目录的 sbt 文件作用不同。 在 sbt 文件所在处打开 CMD，键入sbt指令。sbt 指令只能在 sbt shell 中使用，不能在 Scala REPL 中使用。但是，可以在 sbt shell 中开启Scala解释器，输入console指令。当从sbt中启动解释器的时候，项目中的所有代码会被加载，并且可以直接访问。因此，Scala REPL 只能在项目没有错误的时候才能启动成功。ctrl + D退出。使用 compile 指令编译代码。src/test/scala 目录中包含的是测试代码，使用 test 指令进行测试。当项目中有一个 object 对象，并且含有 main 函数（或者是继承自 App），那么可以使用 run 指令运行程序。如果有多个 main 函数，那么会询问执行哪一个。 1.2 Scala Tutorial两种方式实现 HelloWorld：1234567891011// #1object HelloWorld extends App &#123; println("Hello, World!")&#125;// #2object HelloWorld &#123; def main(args: Array[String]) &#123; println("Hello, World!") &#125;&#125; 官方文档建议使用定义 main 函数的方法来实现，前者有可能出现各种问题。 2. Functions &amp; Evaluation2.1 Programming Paradigms 编程范型函数式编程意味着避免变化 mutation。狭义上说，函数式编程FP意味着不使用变量 mutable variable、分配 assignment、循环 loop以及其他必要的控制结构 imperative control structure。广义上说，集中注意在程序中的函数上。函数在 FP 语言中是第一等公民： 可以在任何地方定义，包括其他函数的内部 可以被当做参数传入以及返回 2.2 Elements of Programming 编程元素交互式 shell，也被称作 RELP(Read-Eval-Print-Loop)，通过输入 scala 开启。Scala 参数与返回值类型： Int：32位整数 Double：64位浮点数 Boolean：布尔值 true 或者 false 计算步骤：12345678910111213141516// 表达式计算：(2 * pi) * radius(2 * 3.14159) * radius6.28318 * radius6.28318 * 1062.8318// 函数计算：sumOfSquares(3, 2+2)sumOfSquares(3, 4)square(3) + square(4)3 * 3 + square(4)9 + square(4)9 + 4 * 49 + 1625 替代模型 substitution model： 只要没有副作用，所有的表示式都可以用替代模型表示。C++ 这个表达式就具有副作用，因为每次计算后C的值都会改变，并不是所有的表达式最后都会计算出一个值（在有限的步骤内），例如：123def loop: Int = loop// 调用loop Call-by-name and Call-by-value：1234567891011121314151617181920// call-by-valuesumOfSquares(3, 2+2)sumOfSquares(3, 4)square(3) + square(4)3 * 3 + square(4)9 + square(4)9 + 4 * 49 + 1625// call-by-namesumOfSquares(3, 2+2)square(3) + square(2+2)3 * 3 + square(2+2)9 + square(2+2)9 + (2+2) * (2+2)9 + 4 * (2+2)9 + 4 * 49 + 1625 call-by-value：每个函数参数都只计算一次call-by-name：当对应该的参数在函数计算体内没有被时用到的话，就不会被计算1234567// which strategy is fastest?def test(x: Int, y: Int) = x * xtest(2,3) // sametest(3+4, 8) // CBVtest(7, 2*4) // CBNtest(3+4, 2*4) //same 2.3 Evaluation Strategies and Termination 计算策略与终止如果表达式 e 的 CBV 计算终止了，那么 CBN 的计算也会终止；反过来则不一定是正确的。1234567def first(x: Int, y: Int) = x// CBNfirst(1, loop)// CBVfirst(1, loop) Scala 通常使用上的计算策略是 call-by-value ，但是如果一个参数类型以 =&gt;开头，那么它使用的策略是 call-by-name：12345def constOne(x: Int, y: =&gt; Int) = 1constOne(1+2, loop) // 1constOne(loop, 1+2) // loop 2.4 Conditionals and Value Definitions 条件语句与值定义if-else在 Scala 中用作表达式，而不是声明：1def abs(x: Int) = if (x &gt;= 0) x else -x 值定义也没有 by-name 与 by-value，def用来定义 by-name,每一次时候都会重新进行计算；而 val 用来定义 by-value，val 的值只会计算一次：def 和 val 的区别在等式右边的表达式不会终止的时候很明显：12345def loop: Boolean = loopdef x = loop // OKval x = loop // lead to an infinite loop &amp;&amp; 和 || 可以写成：12345// anddef and(x:Boolean,y:=&gt;Boolean) = if(x) y else false// ordef or(x:Boolean,y:=&gt;Boolean) = if(x) true else y 2.5 Example square roots with Newton’s method 使用牛顿方法实现平方根实现平方根算法：123456789101112131415161718def abs(x: Double) = if (x &lt; 0) -x else xdef sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x)def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) / x &lt; 0.001 // instead of abs(guess * guess - x) &lt; 0.001def improve(guess: Double, x: Double) = (guess + x / guess) / 2def sqrt(x: Double) = sqrtIter(1.0, x)sqrt(2)sqrt(4)sqrt(1e-6)sqrt(1e60) 2.6 Blocks and Lexical Scope 块代码以及词法作用域将一个任务分解成若干个函数实现是很好的编程风格，但是 sqrtIter, improve, isGoodEnough 这个方法知识 sqrt 的实现，而不是使用。因此，我们可以将这个函数放到另外一个函数的内部，这样还可以有效避免命名空间污染 name-space pollution。12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x) def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) / x &lt; 0.001 def improve(guess: Double, x: Double) = (guess + x / guess) / 2 sqrtIter(1.0, x)&#125; Scala 中的 Block：block 定义在一堆花括号中{...}，内部包含了一系列的定义和表达式，block 的最后一个元素代表了它的值，block 自身是表达式，表达式可以出现在哪儿，block 就能出现在哪儿。block 内部的定义只有在 block 内部是可见的，外部不可见。而外部的定义只要没有在内部重新被定义，那么内部可以直接使用外部的定义。123456val x = 0def f(y: Int) = y + 1val result = &#123; val x = f(3) x * x&#125; + x // result = 16 除非定义在 block 内部被遮蔽 shadow 了，它都是可见的。因此，可以通过清除多余的变量来使程序变得简洁，sqrt 可以简化如下：12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double): Double = if (isGoodEnough(guess)) guess else sqrtIter(improve(guess)) def isGoodEnough(guess: Double) = abs(guess * guess - x) / x &lt; 0.001 def improve(guess: Double) = (guess + x / guess) / 2 sqrtIter(1.0)&#125; 如果一个表达式太长，通常会将表达式写成多行，但是：123456someLongExpression+ someOtherExpression// 相当于someLongExpression;+ someOtherExpression 通常会被当做是两个表达式，可以通过加小括号或者使+放在第一行来告诉 Scala，这个表达式还没有结束，如：12345(someLongExpression+ someOtherExpression)someLongExpression +someOtherExpression 2.7 Tail Recursion 尾递归12345678910111213141516171819202122232425def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)// rewritegcd(14, 21)→ if (21 == 0) 14 else gcd(21, 14 % 21)→ if (false) 14 else gcd(21, 14 % 21)→ gcd(21, 14 % 21)→ gcd(21, 14)→ if (14 == 0) 21 else gcd(14, 21 % 14)→→ gcd(14, 7)→→ gcd(7, 0)→ if (0 == 0) 7 else gcd(0, 7 % 0)→ 7def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)// rewritefactorial(4)→ if (4 == 0) 1 else 4 * factorial(4 - 1)→→ 4 * factorial(3)→→ 4 * (3 * factorial(2))→→ 4 * (3 * (2 * factorial(1)))→→ 4 * (3 * (2 * (1 * factorial(0)))→→ 4 * (3 * (2 * (1 * 1)))→→ 120 两个函数的区别，前者不停地摆动，gcd(14,21) -&gt; gcd(21,14) -&gt; gcd(14,7) -&gt; gcd(7,0),但是总会重新变成对gcd的调用；后者中，每隔几步，我们都会增加一个新的元素到表达式中，表达式越来越长，直到简化到最后的结果。尾递归tail recursion一个函数在最后一步的时候调用它自己，而不能是自己去其他操作的混合操作，这样，这个函数的栈帧 stack frame 可以被重用，被称为尾递归。gcd 函数属于尾递归，而 factorial 函数不属于尾递归。尾递归的判断标准是函数运行最后一步是否调用自身，而不是是否在函数的最后一行调用自身。 function story() {从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。} 来源作者：酿泉链接：http://www.zhihu.com/question/20761771/answer/23254340 12345678910111213141516171819202122// 普通递归调用def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)// 尾递归调用def factorial2(n:Int, result:Int): Int = if (n == 0) result else factorial2(n-1, result * n)factorial(5) // 120factorial2(5,1) // 120// 普通递归调用function f(x) &#123; if (x === 1) return 1; return 1 + f(x-1);&#125;// 尾递归调用function f(x) &#123; if (x === 1) return 1; return f(x-1);&#125; 3. Higher Order Functions3.1 Higher-Order Functions 高阶函数函数式编程语言把函数看成是 第一等值first-class value，也就是说，函数可以被当成参数传递给一个函数或者当成一个结果返回。而将函数当成参数传给另一个函数，或者将函数当做结果返回被称之为高阶函数。函数类型：使用A =&gt; B来表示函数类型，它表示，这个函数接受一个参数类型 A，并且返回结果是类型 B。123456789101112131415def sum(f: Int =&gt; Int, a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f, a+1, b)def sumInt(a: Int, b: Int) = sum(id, a, b)def sumCube(a: Int, b: Int) = sum(cube, a, b)def sumFact(a: Int, b: Int) = sum(fact, a, b)def id(x: Int): Int = xdef cube(x: Int): Int = x * x * xdef fact(x: Int): Int = if (x == 0) 1 else x * fact(x-1)sumInt(0,2)sumCube(0,2)sumFact(0,2) 但是，这样会有一个问题，我们创建了很多小的函数，如 id、cube、fact，这样会显得程序很臃肿，因此介绍函数字面量 function literal，又被称为匿名函数 anonymous function。例如：123456789// (x: Int)是函数的参数，x*x*x是函数体// 其中，参数的类型可以省略，因为编辑器可以根据上下文自动推断出类型(x: Int) =&gt; x * x * x// same asx =&gt; x * x * x// 接收多个参数的函数(x: Int, y: Int) =&gt; x + y// same as(x, y) =&gt; x + y 匿名函数是一种语法糖，可以让程序更加好写，(x1: T1, …, xn: Tn) =&gt; E 可以使用def来定义：{ def f(x1: T1, …, xn: Tn) = E; f }。 3.2 Currying 柯西里化函数返回值为函数：1234567891011121314151617181920212223// 接收参数是一个函数，返回值也是一个函数def sum(f: Int =&gt; Int) : (Int, Int) =&gt; Int = &#123; def sumF(a: Int, b: Int) : Int = if (a &gt; b) 0 else f(a) + sumF(a + 1, b) sumF&#125;// 上面代码可以改写// 这里就没有了重复的参数def sumInts = sum(x =&gt; x)def sumCubes = sum(x =&gt; x * x * x)def sumFactorials = sum(fact)def fact(x: Int): Int = &#123; if (x == 0) 1 else x * fact(x - 1)&#125;sumCubes(1, 10) + sumFactorials(10, 20) // 267634641// 可以直接跳过定义辅助函数sum(x =&gt; x)(1, 10) // 55 转化为多参数：123// 使用语法糖，进一步改写def sum(f: Int =&gt; Int)(a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f)(a + 1, b) 那么，上面 sum 函数的类型是什么？类型为 (Int =&gt; Int) =&gt; (Int, Int) =&gt; Int，函数类型为右结合，也就是说，Int =&gt; Int =&gt; Int 相当于 Int =&gt; (Int =&gt; Int)。12345678def mapReduce(f: Int =&gt; Int, combine: (Int, Int) =&gt; Int, zero: Int)(a: Int, b: Int): Int = &#123; if (a&gt;b) zero else combine(f(a), mapReduce(f, combine, zero)(a+1, b))&#125;def product(f: Int =&gt; Int)(a: Int, b: Int): Int = mapReduce(f, (x, y) =&gt; x * y, 1)(a, b)product(x =&gt; x)(1, 4) 当 mapReduce函数 与 product 函数中间出现其他函数定义的时候，可能会报错：multiple markers at this line- forward reference extends over definition of value res\$0- forward reference extends over definition of value res\$1 3.3 Example Finding Fixed Points 例子：找不动点不动点：x = f(x) 如果一个 x 的值满足前面的等式，那么可以看成是这个函数的不动点。因此，我们可以通过找不动点的方法来实现 sqrt。sqrt(x) 是方程 y =&gt; x / y 的不动点，但是这样计算不能够收敛于一点，于是我们通过与原值取平均的方法来使其收敛，并且可以将其抽取出一个函数：12345678910111213141516171819202122import scala.math._val tolerance = 0.0001def isCloseEnough(x: Double, y: Double) = abs((x - y) / x) / x &lt; tolerancedef fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = &#123; def iterate(guess: Double): Double = &#123; println(s"guess = $guess") val next = f(guess) if (isCloseEnough(guess, next)) next else iterate(next) &#125; iterate(firstGuess)&#125;//fixedPoint(x =&gt; 1 + x/2)(1)//fixedPoint(x =&gt; cos(x))(1)def averageDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2def sqrt(x: Double) = fixedPoint(averageDamp(y =&gt; x / y))(1.0)sqrt(2) 3.4 Scala Syntax Summary 语法总结扩展的巴科斯范式 EBNF(Extended Backus-Naur form)123- | 表示可选- [...] 表示选择（0 或 1）- &#123;...&#125; 表示反复（0 或更多） Types 类型12345Type = SimpleType | FunctionTypeFunctionType = SimpleType &apos;=&gt;&apos; Type | &apos;(&apos; [Types] &apos;)&apos; &apos;=&gt;&apos; TypeSimpleType = IdentTypes = Type &#123;&apos;,&apos; Type&#125; A type can be: A numeric type: Int, Double (and Byte, Short, Char, Long, Float) The Boolean type with the value true and false The String type A function type, like Int =&gt; Int, (Int, Int) =&gt; Int Expressions 类型123456789101112Expr = InfixExpr | FunctionExpr | if &apos;(&apos; Expr &apos;)&apos; Expr else ExprInfixExpr = PrefixExpr | InfixExpr Operator InfixExprOperator = identPrefixExpr = [&apos;+&apos; | &apos;-&apos; | &apos;!&apos; | &apos;~&apos; ] SimpleExprSimpleExpr = ident | literal | SimpleExpr &apos;.&apos; ident | BlockFunctionExpr = Bindings &apos;=&gt;&apos; ExprBindings = ident [&apos;:&apos; SimpleType ] | &apos;(&apos; [ Binding &#123;&apos;,&apos; Binding &#125;] &apos;)&apos;Binding = ident [&apos;:&apos; Type ]Block = &apos;&#123;&apos; &#123; Def &apos;;&apos;&#125; Expr &apos;&#125;&apos; An expression can be: An identifier such as x, isGoodEnough A literal, like 0, 1.0, “abc” A function application, like sqrt(x) An operator application, like -x, y + x A selection, like math.abs A conditional expression, like if (x &lt; 0) -x else x A block, like { val x = math.abs(y) ; x * 2 } An anonymous function, like x =&gt; x + 1 Definitions123456Def = FunDef | ValDefFunDef = def ident &#123;‘(’ [ Parameters ] ‘)’&#125; [‘:’ Type ] ‘=’ ExprValDef = val ident [‘:’ Type ] ‘=’ ExprParameter = ident ‘:’ [ ‘=&gt;’ ] TypeParameters = Parameter &#123;‘,’ Parameter &#125; A definition can be: A function definition, like def square(x: Int) = x * x A value definition, like val y = square(2) A parameter can be: A call-by-value parameter, like (x: Int) A call-by-name parameter, like (y: =&gt; Double) 3.5 Functions and Data 函数和数据类：1234class Rational(x: Int, y: Int) &#123; def numer = x def denom = y&#125; 这样的语句定义了两个实体： 一个新的类型，名字叫做 Rational 一个构造器Rational，用来创建这种类型的元素 对象：一个类型在程序中本质上是一系列的值，而属于一个类型的值称作对象，并且使用 new 操作符和类的构造器来创建一个对象。1new Rational(1, 2) 定义类中的函数称之为方法。 3.6 More Fun With Rationals 更多关于有理数的内容通过选择不同的数据实现方式，但是使用者不会察觉到的这种能力，我们称之为数据抽象 data abstraction。自我引用 self reference在一个类的内部，this 关键字代表了当前方法正在执行的那个对象上。1234567891011121314151617181920212223242526class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) def numer = x / g def denom = y / g def less(another: Rational) = this.numer * another.denom &lt; this.denom * another.numer def max(another: Rational) = if (this.less(another)) another else this def add(another: Rational) = new Rational( numer * another.denom + denom * another.numer, denom * another.denom) def neg = new Rational(-numer, denom) def sub(another: Rational) = add(another.neg) override def toString = numer + "/" + denom&#125; 可以使用 require 来限定构建一个新的对象必须满足的条件，如果不满足这样的条件，提示错误信息，我们称为 前提precondition。除了 require 之外，我们还有 assert 函数，assert 同样接收一个条件和一个可选的提示信息。但是不同的是，assert 抛出的是 AssertionError，而 require 抛出的是 IllegalArgumentException。这表明，它们使用的目的不同： require 被用来强制规定一个函数调用者的先决条件 assert 被用来检验函数自身的代码 在 Scala 中，类隐性地定义了一个构造器，称之为类的主构造器 primary constructor。主构造器取得类的所有参数，并且执行类体内的全部语句。像 Java 一样，我们可以设置不同的构造器，实现如下：12345678class Rational(x: Int, y: Int) &#123; ... def this(x: Int) = this(x, 1) ...&#125; this 用作函数名的时候表示这是类的另一个构造器，并且后面调用了类的主构造器。 3.7 Evaluation and Operators 求值与操作符求值evaluation类的定义如下：1234class C(x1, ..., xm) &#123; ... def f(y1, ..., yn) = b ... &#125;// 下面表达式的值如何计算？new C(v1, ..., vm).f(w1, ..., wn) / 代表，用左边的值替换表达式中右边的值。Example:123456789new Rational(1, 2).numer→ [1/x, 2/y][][new Rational(1, 2)/this] x= 1 // 1 for xnew Rational(1, 2).less(new Rational(2, 3))→ [1/x, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &lt; that.numer * this.denom= new Ration(1, 2).numer * new Rational(2, 3).denom &lt; new Ration(2, 3).numer * new Rational(1, 2).denom→→ 1 * 3 &lt; 2 * 2→→ true 操作符operator任何接收一个参数的方法都可以想一个插入的操作符一样使用，例如：123r add s r.add(s)r less s /* in place of */ r.less(s)r max s r.max(s) 在Scala中，操作符可以当做标识符，因此，标示符可以是： 数字、字母组合：以字母开头，后面跟着一系列的字母或者数字 符号：以一个操作符开头，后面跟着其他的操作符 下划线符号 ‘_’ 被当做一个字母 数字、字母组合的标识符同样可以下划线加操作符结尾 以下操作符都是合法的：x1*+?%&amp;vector++counter=由于在Scala中，前置的操作符，例如负数操作符 - 和中间的操作符，例如减号操作符 - 是不同的，因此需要进行特殊的转换，使用前缀 unary_ 加上操作符来表示。1234567891011121314151617181920class Rational(x: Int, y: Int) &#123; ... def &lt; (that: Rational) = this.numer * that.denom &lt; this.denom * that.numer def max(that: Rational) = if (this &lt; that) that else this def + (another: Rational) = new Rational( numer * another.denom + denom * another.numer, denom * another.denom) def unary_- : Rational = new Rational(-numer, denom) def - (another: Rational) = this + -another ...&#125; 需要注意的是， 如果一个方法以符号结尾，那么它与返回值: 之间必须要有空格隔开，否则会报错，因为冒号也是一个合法的符号，编译器会把冒号也看成是方法名的一部分。操作符的优先级：取决于它的第一个字符，如下表优先级依次变大：(all letters)|^&amp;&lt; &gt;= !:+ -* / %(all other special characters)1234567a + b ^? c ?^ d less a ==&gt; b | c=&gt;a + b ^? (c ?^ d) less a ==&gt; b | c(a + b) ^? (c ?^ d) less a ==&gt; b | c(a + b) ^? (c ?^ d) less (a ==&gt; b) | c((a + b) ^? (c ?^ d)) less (a ==&gt; b) | c((a + b) ^? (c ?^ d)) less ((a ==&gt; b) | c) 3.8 Assignment自己编写 test 测试，内容的格式如下：123test("adding ints") &#123; assert(1 + 2 === 4)&#125; 测试名称叫做 add ints，asser t表示尝试进行 === 左边的操作，看是否与右边的结果相等，不相等则测试不通过，输出测试名称，以及测试没有通过的原因。如果使用 == 则只报错不输出原因。如果暂时不需要对写好的某个测试犯法执行，那么将 test 改成 ignore，就不会执行。我们可能需要给同样的测试对象实现不同的方法，一种办法是重复创建多次，更简便的方法是创建一个与测试分离的特征 trait 中，这样当我们创建 trait 实例的时候我们可以访问内部的所有变量。123456789trait TestSets &#123; val s1 = singletonSet(1) val s2 = singletonSet(2) val s3 = singletonSet(3)&#125;new TestSets &#123; assert(contains(s1, 2), "Singleton") // FunSets.contains($anon.this.s1, 2) was false Singleton&#125; 未完，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/12/07/Coursera-FP-in-Scala-Note-Part1/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo Blog 同步备份]]></title>
      <url>%2F2016%2F12%2F06%2FHexo-Backup%2F</url>
      <content type="text"><![CDATA[1. 备份电脑A：1.在 Github 上新建一个仓库，例如 blog。2.上传电脑A本地Hexo博客的源文件到 Github 的 blog 仓库中：1) 删除根目录和主题目录下的 .git 文件夹2) 修改根目录下的 .gitignore 文件为： 12.deploy*/public/ 3) 依次执行以下指令，同步源文件至 Github： 123456$ git init$ git add .$ git commit -m "创建Hexo" # 更新信息$ git git remote add origin git@github.com:Username/Reponame$ git push -u origin master$ git pull -rebase origin master # 如果出现冲突先执行这条语句 即可将博客源文件上传到 Github。 2. 同步电脑B：1.安装 Git。2.安装 Node.js。3.安装 Hexo： 1$ npm install -g hexo-cli 4.选择一个同步到本地的文件夹，执行 git clone： 1$ git clone git@github.com:Username/Reponame 到这里，两台电脑的 Hexo 环境一致，Hexo 博客源文件也一样。 3. 两台电脑同步更新博客：1.先检查git pull，将本地博客源文件更新至最新版本： 1$ git pull 2.新建或修改博客内容，进行本机预览等操作： 12$ hexo new &lt;新的博客&gt;$ hexo server 3.同步 Hexo 源文件至 Github： 123$ git add .$ git commit -m "更新描述"$ git push origin master 4.最后生成 Hexo 静态博客文件并部署。 12$ hexo generate$ hexo deploy 本文参考原文，并重新整理，转载请注明出处：http://hijacking.cn/2016/12/06/Hexo-Backup/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0 - 读书笔记 (1)]]></title>
      <url>%2F2016%2F07%2F01%2FEffective-OC-Note-Part1%2F</url>
      <content type="text"><![CDATA[此笔记是在阅读《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》 时所整理，方便今后查阅。 第1章 熟悉OC1. 了解OC语言的起源2. 在类的头文件中尽量少引入其他头文件尽量晚地#import需要的头文件，使用@class进行『向前声明』（forward declaring）。如果两个类在各自头文件中引入对方的头文件，则会导致『循环引用』（chicken-and-egg situation）。虽然#import不会像#include导致死循环，但是两个类里有一个无法被正确编译。 最好将协议单独放在一个头文件中，如果把协议放在某个大的头文件里，那么只要引入此协议，就必定会引入那个头文件中的全部内容。然有些协议，例如委托协议（delegate protocol）就不用单独写一个头文件。 3. 多用字面量语法，少用与之等价的方法字面量语法（literal syntax），一种语法糖（syntactic sugar） 1NSNumber *someNumber = [NSNumber numberWithInt:1]; 等价于： 1NSNumber *someNumber = @1; 还可以使用：字面量字符串 1NSString *someString = @“Effective Objective-C 2.0”; 字面量数值 1NSNumber *floatNumber = @2.5f; 字面量数组 12NSArray *animals = @[@“cat”, @“dog”, @“mouse”, @“badger”];NSString *dog = animals[1]; // 取下标操作，subscripting 使用字面量语法更加安全，因为一旦出现nil，便会抛出异常。字面量字典 12NSDictionary *personData = @&#123;@“firstName” : @“Matt”, @“lastName” : @“Galloway”, @“age” : @28&#125;;NSString *lastName = personData[@“lastName”]; 可变数组与字典 12mutableArray[1] = @“dog”;mutableDictionary[@“lastName”] = @“Galloway”; 局限使用字面量语法创造出来的对象都是不可变的，若想变成可变版本，需要复制一份： 1NSMutableArray *mutable = [@[@1, @2, @3, @4, @5] mutableCopy]; 4. 多使用类型常量，少用#define 预处理指令将 1#define ANIMATION_DERATION 0.3 替换为 1static const NSTimeInterval kAnimationDuration = 0.3; 此方法包含类型信息，清楚地描述了常量的含义。并且注意命名方式，若常量局限于某个编译单元（.m文件）之内，则在前面加字母k；若常量在类之外可见，则通常以类名为前缀。注意，变量一定要同时用static和const来声明。const用来保证变量不能被修改，而static意味着该变量仅在定义此变量的编译单元中可见。假如不加static，那么编译器会创建一个external symbol。 有时候需要对外公开某个常量。比如通知中心派发通知的时候，需要给通知一个名称。此类常量需放在『全局符号表』（global symbol table）中，以便可以在编译单元之外使用。 12345// In the header fileextern NSString *const EOCStringConstant;// In the implementation fileNSString *const EOCStringConstant = @"VALUE"; 在头文件中声明，在实现文件中定义。并且，命名时应该用与之相关的类名做前缀。如上例需要对可见的话 12345// EOCAnimatedView.hextern const NSTimeInterval EOCAnimatedViewAnimationDuration;// EOCAnimatedView.mconst NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3; 5. 用枚举表示状态、选项、状态码123456enum EOCConnectionState &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef enum EOCConnectionState EOCConnectionState; 可以指定底层数据类型（underlying type）来保存枚举类型，可以向前声明枚举变量。 1enum EOCConnectionStateConnectionState : NSInteger &#123; /* ... */ &#125; Foundation框架中定义了一些辅助的宏，可以用这些宏来定义枚举值。 1234567891011typedef NS_ENUM(NSUUnteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) &#123; EOCPermittedDirectionUP = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3,&#125;; 需要以按位或操作来组合枚举时使用NS_OPTIONS，不需要互相组合时，使用NS_ENUM定义。 第2章 对象、消息、运行期6. 理解『属性』这一概念OC对象通常会把所需的数据保存为各种实例变量，实例变量一般通过『存取方法』（access method）来访问。如果使用属性，编译器会自动编写访问这些属性所需的方法（getter、setter），叫做『自动合成』（autosynthesis）。除此之外，还自动向类中添加适当类型的实例变量，并且在属性名前加下划线，作为实例变量的名字。如果使用@dynamic关键字，会告诉编译器，不要自动创建属性所用的实例变量，也不要为其创建存取方法。属性特质 原子性如果属性具备nonatomic特质，则不使用同步锁。 读/写权限 readwrite：拥有getter和setter readonly：仅拥有getter 内存管理语义 assign：设置方法只会执行针对『纯量类型』（scalar type，例如CGFloat或NSInteger等）的简单赋值操作。 strong：定义一种『拥有关系』（owning relationship）。设置方法会先保留新值，并释放旧值，然后再将新值设置上去。 weak：定义一种『非拥有关系』（nonowning relationship）。设置方法既不保留新值，也不释放旧值。在属性所指的对象销毁时，属性值也会清空（nil out）。 unsafe_unretained：语义与assign相同，但是适用于『对象类型』，表达一种『非拥有关系』，当目标对象销毁时，属性值不会自动清空（不安全，unsafe）。 copy：所属关系与strong类似。但设置方法并不保留新值，而是将其『拷贝』。 方法名可以通过getter\setter=&lt; name &gt;来设置获取方法或者设置方法的方法名。 7. 在对象内部尽量直接访问实例变量在对象之外访问实例变量时，应该通过属性来做。在对象内部时，建议采用直接访问的形式读取，通过属性来设置。特殊情况： 在初始化方法中，应该直接访问实例变量。 在懒加载中，应该使用 『获取方法』来访问属性。 8. 理解『对象等同性』这一概念某些对象提供了特殊的『等同性判定方法』（equality-checking method）。如isEqualToString，isEqual等。自己创建等同性判定方法： 12345678910111213141516171819- (BOOL)isEqualToPerson:（EOCPerson *）otherPerson &#123; if (self == object) return YES; if (![_firstName isEqualToString: otherPerson.firstName]) return NO; if (![_lastName isEqualToString: otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES;&#125;- (BOOL)isEqual:(id)object &#123; if ([self class] == [object class]) &#123; return [self isEqualToPerson:(EOCPerson *)object]; &#125; else &#123; return [super isEqual:object]; &#125;&#125; 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未被相同（isEqual 与 hash 方法）。 9. 以『类族模式』隐藏实现细节『类族』（class cluster）是一种很有用的模式（pattern），可以隐藏『抽象基类』（abstract base class）背后的实现细节，对外提供一套简单的公共接口。 12- (BOOL)isKindOfClass: classObj // 判断是否是这个类或者这个类的子类的实例- (BOOL)isMemberOfClass: classObj // 判断是否是这个类的实例 10. 在既有类中使用关联对象存放自定义数据从对象所属的类中继承一个子类，然后改用子类对象。然而，并非所有情况都可以那么做，有时候类的实例可能由某种机制所创建，而开发者无法令这种机制创建出自己所写的子类实例。这时候可以采用『关联对象』（Associated Object）。例如，想在一个类里同时处理多个警告信息视图，如果能在创建警告视图的时候直接把处理每个按钮的逻辑都写好，那么代码就简洁而清晰多了。 12345678910111213141516171819#import &lt;objc/runtime.h&gt;static void *EOCMyAlertViewKey = @"EOCMyAlertViewKey";- (void)askUserQuestion &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Question" message:@"what do you want to do" delegate:self cancelButtonTitle:@"取消" otherButtonTitles:@"继续", nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex) &#123; if (buttonIndex == 0) &#123; [self doCancel]; &#125; else &#123; [self doContinue]; &#125; &#125;; objc_setAssociatedObject(alter, EOCMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);[alter show];&#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey); block(buttonIndex);&#125; 但是，采用该方法的时候块可能要捕捉某些变量，会造成『保留环』（retain cycle）。这种做法只有在其他办法行不通的时候才考虑使用。取代方法是从中继承子类，把块保存为子类中的属性。 11. 理解objc_msgSend的作用对象上调用方法在OC中叫做『传递消息』（pass a message）。消息有 名称 和 选择子（selector）。 1234// OC中给对象发送消息id returnValue = [someObject messageName: parameter];// 转化为一条标准的C语言函数调用id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); 消息由接受者、选择子及参数构成。给某对象『发送消息』（invoke a message）也就相当于在该对象上『调用方法』（call a method）。发送给某对象的全部消息都要由『动态消息派发系统』（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 12. 理解消息转发机制当对象接收到无法解读的消息后，就会启动『消息转发』（message forwarding）机制，由此过程告诉对象应该如何处理未知消息。 12// 控制台如下信息说明 曾向某个对象发送了一条其无法解读的消息，从而启动了消息转发机制，并将此消息发给了NSObject的默认实现unrecognized selector sent to instance 0x87... 开发者在编写自己的类时，可于转发过程中设置挂钩，用以执行预定的逻辑，而不使应用程序崩溃。 消息转发分为两大阶段，第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个『未知的选择子』（unknown selector），叫做『动态方法解析』（dynamic method resolution）。 第二阶段设计『完整的消息转发机制』（full forwarding mechanism）。首先，接收者看看有没有其他对象能处理这条消息，若有，则运行期系统会把消息转给那个对象，消息转发过程结束。若没有『备援的接收者』（replacement receiver），则启动完整的消息转发机制，runtime会把与消息有关的全部细节封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 12345678910// 动态方法解析// 对象收到无法解读的消息后，首先将调用其所属类的下列类方法+ (BOOL)resolveInstanceMethod:(SEL)selector;// 备援接收者// runtime问接收者，能不能把这条消息转发给其他接收者来处理- (id)forwardingTargetForSelector:(SEL)selector;// 完整的消息转发- (void)forwardInvocation:(NSInvocation *)invocation; 13. 用『方法调配技术』测试『黑盒方法』方法调配（method swizzling）：与给定选择子名称对应的方法可以在运行期改变。既不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能。新功能将在本类的所有实例中生效。 1234// 交换方法实现void method_exchangeImplementations(Method m1, Method m2)// 获取方法实现Method class_getInstanceMethod(Class aClass, SEL aSelector) 通过此方案，可以为那些『完全不知道其具体实现的』（complete opaque）黑盒方法增加日志记录功能。 14. 理解『类对象』的用意12345678910111213141516171819// id类型定义typedef struct objc_object &#123; Class isa;&#125; *id;// Class类型定义typedef struct objc_class *Class;struct objc_Class &#123; Class *isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols;&#125; 在类继承体系中查询类型信息：isMemberOfClass判断对象是否为某个特定类的实例，isKindOfClass判断对象是否为某类或其派生类的实例。每个实例都有一个指向Class对象的指针，用以表明其类型。 第3章 接口与API设计15. 用前缀避免命名空间冲突OC没有其他语言内置的『命名空间』（namespace）机制。选择与公司或应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。若自己所开发的程序库中使用到了第三方库，则应为其中的名称加上前缀。 16. 提供『全能初始化方法』把这种可为对象提供必要信息以便其能完成工作的初始化方法叫做『全能/指定初始化方法』（designated initializer）。 12345678910111213141516171819202122// Rectangle.m- (id)initWithWidth:(float)width andHeight:(float)height &#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// 如果有人调用[[Rectangle alloc]init]来创建，所有的实例变量都会设为0（或是与0等价的值）// 不过我们一般希望自己能设置默认的宽度和高度，或者抛出异常// 使用下面任意一种方法来覆写init方法// Using default values- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Throwing an exception- (id)init &#123; @throw [NSException exceptionWithName:NSInternalInconsistentcyException reason:@"Must use initWithWidth:andHeight: instead." useInfo:nil];&#125; 全能初始化方法的调用链一定要维系。并且，如果子类的全能初始化方法与超类方法的名称不同，那么总应覆写超类的全能初始化方法（调用本类的全能初始化方法）。如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。有时候，可能需要编写多个全能初始化方法，因为对象的实例可能有两种完全不同的创建方式。12345678910111213141516171819202122232425262728293031323334353637383940414243// Rectangle.m// Designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// Superclass&apos;s designated initializer- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Initializer from NSCoding- (id)initWithCoder:(NSCoder *)decoder &#123; // call through to super&apos;s designated initializer if ((self = [super init])) &#123; _width = [decoder decodeFloatForKey:@&quot;width&quot;]; _height = [decoder decodeFloatForKey:@&quot;height&quot;]; &#125; return self;&#125;// Square.m// Designated initializer- (id)initWithDimension:(float)dimension &#123; return [super initWidth:dimension andHeight:dimension];&#125;// Superclass&apos;s designated initializer- (id)initWithWidth:(float)width andHeight:(float)height &#123; float dimension = MAX(width, height); return [self initWithDimension:dimension];&#125;// NSCoding designated initializer- (id)initWithCoder:(NSCoder *)decoder &#123; if ((self = [super initWithCoder:decoder])) &#123; // Square&apos;s specific initializer &#125;&#125; 每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。 17. 实现descripiton方法自定义类时可以覆写description方法并将描述此对象的字符串返回。 1234// Person.m- (NSString *)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, \"%@ %@\"&gt;", [self class], self, _firstName, _lastName];&#125; 有个简单的方法，可以借助NSDictionary类的description方法，可以在description中输出很多互不相同的信息。 123- (NSString *)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@&gt;", [self class], self, @&#123;@"title":_title, @"latitude":@(_latitude), @"longitude":@(_longitude)&#125;];&#125; debugDescription是开发者在调试器（debugger）中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，此方法直接调用description。实现description方法返回一个有意义的字符串，用以描述该实例。但若想在调试时打印出更详尽的对象描述信息，则应该实现debugDescription方法。 18. 尽量使用不可变对象设计类的时候，应该充分运用属性来封装数据。而在使用属性时，可将其声明为『只读』（read-only）。但是设置为read-only的属性在对象外部仍然可以通过『键值编码』（Key-Value Coding, KVC）技术setValue:forKey:设置这些属性值。不过这么做等于违规地绕过了本类所提供的API，使用这种『杂技代码』（hack）的话，得自己来应对可能出现的问题。尽量创建不可变的对象。若某属性仅可用于对象内部修改，则在『class-continuation分类』中将其由readonly属性扩展为readwrite属性。不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。 19. 使用清晰而协调的命名方式方法命名： 如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语 应该把表示参数类型的名词放在参数前面 如果方法要在当前对象上执行操作，那么就应该包括动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词 将get这个前缀留给那些借由『输出参数』来保存返回值的方法，比如getCharacters:range，调用此方法时，要在首个参数中传入数组，该方法所获取的字符正是要放到这个数组里面。 20. 为私有方法名添加前缀可以使用p_或者类名前缀作为前缀。 21. 理解Objective-C错误模型OC中的异常只用于处理致命错误（fatal error），在非致命错误（nonfatal error）时，OC所用的编程范式为：令方法返回nil/0，或者是使用NSError，以表明其中有错误发生。NSError对象里封装了三条信息： Error domain（错误范围，类型为字符串）：发生错误的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。 Error code（错误码，类型为整数）：独特的错误代码，指明在某个范围内具体发生了何种错误。 User info（用户信息，类型为字典）：有关此错误的额外信息，其中或许包含一段『本地化的描述』，或许还有含有导致该错误发生的另外一个错误。NSError经由方法的『输出参数』返回给调用者。 1- (BOOL)doSomething:(NSError **)error 这样，此方法不仅能有普通的返回值，而且还能经由『输出参数』把NSError对象回传给调用者。 12345NSError *error = nil;BOOL ret = [object doSomething:&amp;error];if (error) &#123; // There was an error&#125; 像这样的方法一般都会返回Boolean值，用来表示成功了还是失败了。如果不关注具体的错误信息，那么直接判断这个Boolean值就好。 1234BOOL ret = [object doSomething:nil];if (ret) &#123; // There was an error&#125; 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。在错误不那么严重的情况下，可以指派『委托方法』（delegate method）来处理错误，也可以把错误信息放在NSError对象里，经由『输出参数』返回给调用者。 22. 理解NSCopying协议OC中，使用copy方法来进行拷贝。如果想令自己的类支持拷贝操作，那么就要实现NSCopying协议，该协议只有一个方法： 1- (id)copyWithZone:(NSZone *)zone 以前开发程序时，需要把内存分成不同的区（zone），而对象会创建在某个区里。而现在每个程序只有一个区：『默认区』（default zone）。因此不必担心zone参数。NSMutableCopying协议定义了： 1- (id)mutableCopyWithZone:(NSZone *)zone 无论当前实例是否可变，若需获取其可变版本的拷贝，均应调用mutableCopy方法。同理，若需要不可变的拷贝，则总应通过copy方法来获取。深拷贝（deep copy）：在拷贝对象自身时，将其底层数据也一并复制过去。浅拷贝（shallow copy）：只拷贝容器对象本身，而不复制其中数据。一般情况下会使用浅拷贝。如果所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 12345- (id)deepCopy &#123; Person *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;&#125; 未完，不定期更新，接下篇。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/07/01/Effective-OC-Note-Part1/，其他请联系Jiawei LU]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS 去除优酷视频广告]]></title>
      <url>%2F2016%2F06%2F27%2FMacOS-Block-Youku-Ad%2F</url>
      <content type="text"><![CDATA[教程最早发表于威锋网，原帖地址。未经允许，不得转载。 1. 修改hosts文件1.打开 Finder，同时按住 Shift + Command + G ，输入 /private/etc/ ，然后前往，找到 hosts 文件。 2.将 hosts 文件拷贝一份到桌面上，然后使用文本编辑器添加如下字段： 123456789101112131415127.0.0.1 atm.youku.com127.0.0.1 fvid.atm.youku.com127.0.0.1 html.atm.youku.com127.0.0.1 valb.atm.youku.com127.0.0.1 valf.atm.youku.com127.0.0.1 valo.atm.youku.com127.0.0.1 valp.atm.youku.com127.0.0.1 lstat.youku.com127.0.0.1 speed.lstat.youku.com127.0.0.1 urchin.lstat.youku.com127.0.0.1 stat.youku.com127.0.0.1 static.lstat.youku.com127.0.0.1 valc.atm.youku.com127.0.0.1 vid.atm.youku.com127.0.0.1 walp.atm.youku.com 3.保存并退出，将修改好的 hosts 文件替换原来的 hosts 文件，有密码会提示输入密码。 2. 删除优酷缓存文件夹打开 Finder，同时按住 Shift + Command + G ，输入 ~/Library/Preferences/Macromedia/Flash Player/#SharedObjects/ ，看到一个字母数字组成的文件夹，例如 479H5MNT（名字随机生成），将文件夹内的 static.youku.com 文件夹删除。 3. 网页设置随便打开一个优酷视频网页，此时应该没有广告了，点击右下角的设置按钮，优先画质选择超清或高清，确定。 4. 设置文件权限再次进入 ~/Library/Preferences/Macromedia/Flash Player/#SharedObjects/ 位置，一直进入里面的文件夹，找到 YOUKU_FSO_PROXY.sol 文件。右键点击选择“显示简介”，在最后共享与权限中将所有账户权限改成只读（不能修改点击右下角的锁解锁），最后点击通用中的已锁定。 对于极少部分人，如果按照上面步骤出现优酷黑屏，提示广告被屏蔽的话，试着将第二步中那个数字和字母随即生成的文件夹，如 479H5MNT ，整个删除，再按照上面的方法试一遍。 本文采用CC4.0协议授权，转载请注明出处：http://hijacking.cn/2016/06/27/MacOS-Block-Youku-Ad/，其他请联系Jiawei LU]]></content>
    </entry>

    
  
  
</search>
